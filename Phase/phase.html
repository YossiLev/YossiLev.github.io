<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Gerchberg–Saxton Phase Retrieval (ABCD)</title>
<style>
body {
    font-family: sans-serif;
}
.container {
    display: flex;
    flex-direction: row;
    gap: 20px;
}
.column {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
canvas {
    border: 1px solid #333;
}
.controls {
    margin-top: 10px;
}
label {
    margin-right: 10px;
}
button {
    height:30px;
    font-size: 20px;
    margin-right: 10px;
}
</style>
</head>

<body>

<h2>Gerchberg–Saxton Phase Retrieval (Two-Plane, ABCD)</h2>

<div class="controls">

    <div>
        <button onclick="generateGaussian(0)">Generate Gaussian Beam</button>
        <button onclick="generateGaussian(1)">Generate crazy Beam</button>
        <label>Image Size:
        <select name="N" id="NSelect" value="256">
            <option value="128">128</option>
            <option value="256" selected>256</option>
            <option value="512">512</option>
            <option value="1024">1024</option>
        </select></label>&nbsp;&nbsp;
        <label>A <input id="A" value="1" size="4"></label>
        <label>B <input id="B" value="0.055" size="4"></label>
        <label>C <input id="C" value="0" size="4"></label>
        <label>D <input id="D" value="1" size="4"></label>
    </div>
    </br>
    <div>
        <label>Image 1&nbsp;&nbsp;<input type="file" id="readimage1"></label>
    </div>
    </br>
    <div>
        <label>Image 2&nbsp;&nbsp;<input type="file" id="readimage2"></label>
    </div>
    </br>
    <div>
        <button onclick="initRandomization()">Randomize Phase</button>
        <button onclick="iterateOneDirection(1)">One Forward Iteration</button>
        <button onclick="iterateOneDirection(-1)">One Backward Iteration</button>
        <button onclick="iterate(1)">One GS Iteration</button>
        <button onclick="iterate(10)">10 GS Iterations</button>
        <button onclick="iterate(100)">100 GS Iterations</button>
    </div>
    <div>
        <button onclick="pushDistance(0.01)">Forward Cm</button>
        <button onclick="pushDistance(-0.01)">Backward Cm</button>
    </div>
</div>

<br>

<div class="container">

<!-- Plane 1 -->
<div class="column">
    <canvas id="i1" width="256" height="256"></canvas>
    <canvas id="c1" width="256" height="256"></canvas>
</div>
<div class="column">
    <canvas id="p1" width="256" height="256"></canvas>
    <canvas id="d1" width="256" height="256"></canvas>
</div>

<!-- Plane 2 -->
<div class="column">
    <canvas id="i2" width="256" height="256"></canvas>
    <canvas id="c2" width="256" height="256"></canvas>
</div>
<div class="column">
    <canvas id="p2" width="256" height="256"></canvas>
    <canvas id="d2" width="256" height="256"></canvas>
</div>

</div>

<script>

    
let N = 256;
const lambda = 1e-6;
const dx = 5.2e-6;
const k = 2 * Math.PI / lambda;

let currentModeImage = -1;

let I1 = new Float32Array(N*N);
let I2 = new Float32Array(N*N);

let S1 = new Float32Array(N*N);
let S2 = new Float32Array(N*N);

let phase1 = new Float32Array(N*N);
let phase2 = new Float32Array(N*N);

let field1 = new Float32Array(2*N*N);
let field2 = new Float32Array(2*N*N);

function idx(x,y){ return y*N+x; }

function readImageData(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = URL.createObjectURL(file);
        
        img.onload = () => {
            const canvas = new OffscreenCanvas(img.width, img.height);
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            let centerXSum = 0, centerYSum = 0, totalIntensity = 0;
            console.log("Original image size:", imageData.width, imageData.height);
            for (let ih = 0; ih < imageData.height; ih++) {
                for (let iw = 0; iw < imageData.width; iw++) {          
                    const index = 4 * (ih * imageData.width + iw);
                    const intensity = imageData.data[index]; // Grayscale, so R=G=B
                    if (intensity > 2) { // Threshold to ignore background
                        centerXSum += iw * intensity;
                        centerYSum += ih * intensity;
                        totalIntensity += intensity;
                    }
                }
            }
            centerXSum /= totalIntensity;
            centerYSum /= totalIntensity;
            console.log("Total intensity:", totalIntensity);
            console.log("Center of mass:", centerXSum, centerYSum);
            let startX = Math.max(0, Math.floor(centerXSum - N / 2));
            let startY = Math.max(0, Math.floor(centerYSum - N / 2));
            if (startX + N > imageData.width) {
                startX = imageData.width - N;
            }
            if (startY + N > imageData.height) {
                startY = imageData.height - N;
            }
            console.log("Cropping to:", startX, startY, startX + N, startY + N);
            const croppedData = new Float32Array(N*N);
            for (let y = 0; y < N; y++) {
                for (let x = 0; x < N; x++) {
                    const srcIndex = 4 * ((startY + y) * imageData.width + (startX + x));
                    const dstIndex = y * N + x;
                    croppedData[dstIndex] = imageData.data[srcIndex];

                }
            }   
            console.log("Float croppedData:", croppedData);
            console.log("Cropped data [256][256]:", croppedData[256 * N + 256]);

            resolve(croppedData);
        };
        img.onerror = reject;
    });
}
document.getElementById("readimage1").addEventListener("change", () => {
    const file = document.getElementById("readimage1").files[0];
    if (!file) return;
    readImageData(file).then(data => {
        for (let i = 0; i < N * N; i++) {
            I1[i] = data[i] / 255.0;
        }
        drawImage(i1,I1, -1);
    
        console.log("Float image:", I1);
    }).catch(error => {
        console.error("Error loading image:", error);
    });

});


document.getElementById("readimage2").addEventListener("change", () => {
  const file = document.getElementById("readimage2").files[0];
  if (!file) return;
    readImageData(file).then(data => {
        for (let i = 0; i < N * N; i++) {
            I2[i] = data[i] / 255.0;
        }
        drawImage(i2,I2, -1);

        console.log("Float image:", I2);
    }).catch(error => {
        console.error("Error loading image:", error);
    });

});

document.getElementById("NSelect").addEventListener("change", (event) => {
    N = parseInt(event.target.value);
    I1 = new Float32Array(N*N);
    I2 = new Float32Array(N*N);

    S1 = new Float32Array(N*N);
    S2 = new Float32Array(N*N);

    phase1 = new Float32Array(N*N);
    phase2 = new Float32Array(N*N);

    field1 = new Float32Array(2*N*N);
    field2 = new Float32Array(2*N*N);

    // Update canvas sizes
    const canvases = ['i1', 'i2', 'c1', 'c2', 'p1', 'p2', 'd1', 'd2'];
    canvases.forEach(id => {
        const canvas = document.getElementById(id);
        canvas.width = N;
        canvas.height = N;
    });

    drawAll();
});
/* ---------- Gaussian generation ---------- */
function generateGaussian(mode=0) {
    const w0 = 60;
    const factor = 6;
    const shiftX = 10;
    const shiftY = 50;
    currentModeImage = mode;

    // --- TRUE field (used only to generate intensities) ---
    switch(mode){
        case 0:
            // Simple Gaussian
            for(let y=0;y<N;y++){
                for(let x=0;x<N;x++){
                    let X = factor * (x - N/2) + shiftX;
                    let Y = factor * (y - N/2) + shiftY;
                    let r2 = X*X + Y*Y;
    
                    I1[idx(x,y)] = Math.exp(-r2/(16*w0*w0));
                    phase1[idx(x,y)] = 0;   // TRUE phase (hidden)
                }
            }
            break;
        case 1:
        
            for(let y=0;y<N;y++){
                for(let x=0;x<N;x++){
                    let X = factor * (x - N/2) + shiftX;
                    let Y = factor * (y - N/2) + shiftY;
                    let r2a = 4 * X*X + (Y+180)*(Y+180);
                    let r2b = (X+290)*(X+290) + Y*Y;           
                    let r2c = (X+480)*(X+480) + (Y-70)*(Y-70);
                    let r2d = (X)*(X) + (Y)*(Y);

                    I1[idx(x,y)] = Math.exp(-r2a/(w0*w0)) + Math.exp(-r2b/(w0*w0)) + Math.exp(-r2c/(w0*w0)) + Math.exp(-r2d/(w0*w0));
                    phase1[idx(x,y)] = 0;   // TRUE phase (hidden)
                }
            }
            break;
    }
    // True field → plane 2
    updateFieldFromIPhase(field1, I1, phase1);
    propagateABCD(field1, field2);
    extractIntensity(field2, I2);
    extractPhase(field2, phase2);
    extractPhase(field1, phase1);


    // // --- THROW PHASE AWAY ---
    //randomizePhase(phase1);
    //randomizePhase(phase2);

    // // Initialize fields with correct intensity but random phase
    //updateFieldFromIPhase(field2, I2, phase2);

    drawAll();
}

function randomizePhase(phase){
    for(let i=0;i<N*N;i++){
        phase[i] = (Math.random()*2 - 1) * Math.PI;
    }
}
/* ---------- Single GS iteration ---------- */
function initRandomization() {
    randomizePhase(phase1);
    updateFieldFromIPhase(field1, I1, phase1);
    drawAll();
}

function iterateOneDirection(dir) {
    if (dir === 1) {
        // Plane 1 → Plane 2
        enforceIntensity(field1, I1);
        propagateABCD(field1, field2);
        extractIntensity(field2, S2);
        extractPhase(field2, phase2);
    } else {
        // Back propagation (inverse ABCD)
        enforceIntensity(field2, I2);
        propagateABCD(field2, field1, true);
        extractIntensity(field1, S1);
        extractPhase(field1, phase1);
    }
    drawAll();
}

function iterate(n){
    for(let it=0;it<n;it++){
        // Plane 1 → Plane 2
        enforceIntensity(field1,I1);
        propagateABCD(field1,field2);
        extractIntensity(field2,S2);
        extractPhase(field2,phase2);

        // Back propagation (inverse ABCD)
        enforceIntensity(field2,I2);
        propagateABCD(field2,field1,true);
        extractIntensity(field1, S1);
        extractPhase(field1,phase1);
    }
    drawAll();
}

/* ---------- Core operations ---------- */
function updateFieldFromIPhase(out,I,phase){
    for(let i=0;i<N*N;i++){
        let a = Math.sqrt(I[i]);
        out[2*i]   = a * Math.cos(phase[i]);
        out[2*i+1] = a * Math.sin(phase[i]);
    }
}

function enforceIntensity(field,I){
    for(let i=0;i<N*N;i++){
        let re = field[2*i];
        let im = field[2*i+1];
        let mag = Math.sqrt(re*re + im*im) + 1e-12;
        let target = Math.sqrt(I[i]);
        field[2*i]   *= target / mag;
        field[2*i+1] *= target / mag;
    }
}

function extractIntensity(field,I){
    for(let i=0;i<N*N;i++){
        let re = field[2*i];
        let im = field[2*i+1];
        I[i] = re*re + im*im;
    }
}

function extractPhase(field,phase){
    for(let i=0;i<N*N;i++){
        phase[i] = Math.atan2(field[2*i+1],field[2*i]);
    }
}

function pushDistance(dz){
    const B = parseFloat(document.getElementById("B").value);
    const newB = B + dz;
    document.getElementById("B").value = newB.toFixed(6);
    generateGaussian(currentModeImage);
}

function angularSpectrumPropagate(field, output, {
  wavelength,
  dx,
  dy,
  z
}) {
  const Nf = field.length;
  const k = 2 * Math.PI / wavelength;

  let Unew = new Float32Array(2*N*N);
  // 1. Forward FFT
  fft2(field, Unew, false);
  fftshift2D(Unew);

  // 2. Apply transfer function
  for (let y = 0; y < N; y++) {
    const ky = 2 * Math.PI * (y - N/2) / (N * dy);
    for (let x = 0; x < N; x++) {
      const kx = 2 * Math.PI * (x - N/2) / (N * dx);
      const kxy2 = kx*kx + ky*ky;

      if (kxy2 <= k*k) {
        const kz = Math.sqrt(k*k - kxy2);
        const phase = kz * z;
        const cph = Math.cos(phase);
        const sph = Math.sin(phase);
        Unew[2*(y*N + x)] = Unew[2*(y*N + x)] * cph - Unew[2*(y*N + x) + 1] * sph;
        Unew[2*(y*N + x) + 1] = Unew[2*(y*N + x)] * sph + Unew[2*(y*N + x) + 1] * cph;
      } else {
        // Evanescent waves (recommended: suppress)
        Unew[2*(y*N + x)] = 0;
        Unew[2*(y*N + x) + 1] = 0;
      }
    }
  }

  // 3. Inverse FFT
  ifftshift2D(Unew);
  fft2(Unew, output, true);
}


/* ---------- ABCD Fresnel propagation ---------- */
function propagateABCD(input, output, inverse=false){
    const A = parseFloat(document.getElementById("A").value);
    const B = parseFloat(document.getElementById("B").value);
    const D = parseFloat(document.getElementById("D").value);
    angularSpectrumPropagate(input, output, {
        wavelength: lambda,
        dx: dx,
        dy: dx,
        z: inverse ? -B : B
    });
    return;



    const Beff = inverse ? -B : B;
    if (Math.abs(Beff) < 1e-12){
        console.error("B = 0 not supported");
        return;
    }

    let field = new Float32Array(2 * N * N);

    /* ---------- 1) input quadratic phase ---------- */
    for(let y=0;y<N;y++){
        let Y = (y - N/2) * dx;
        for(let x=0;x<N;x++){
            let X = (x - N/2) * dx;
            let q = k * A * (X*X + Y*Y) / (2 * Beff);
            let c = Math.cos(q);
            let s = Math.sin(q);
            let i = 2*(y*N+x);

            let re = input[i];
            let im = input[i+1];

            field[i]   = re*c - im*s;
            field[i+1] = re*s + im*c;
        }
    }

    /* ---------- 2) FFT (centered) ---------- */
    fftshift2D(field);
    fft2(field, output, false);
    fftshift2D(output);

    /* ---------- 3) output quadratic phase ---------- */
    for(let y=0;y<N;y++){
        let Y = (y - N/2) * dx;
        for(let x=0;x<N;x++){
            let X = (x - N/2) * dx;
            let q = k * D * (X*X + Y*Y) / (2 * Beff);
            let c = Math.cos(q);
            let s = Math.sin(q);
            let i = 2*(y*N+x);

            let re = output[i];
            let im = output[i+1];

            output[i]   = re*c - im*s;
            output[i+1] = re*s + im*c;
        }
    }

    /* ---------- 4) optional amplitude scale ---------- */
    const scale = 1 / Math.abs(lambda * Beff);
    for(let i=0;i<2*N*N;i++){
        output[i] *= scale;
    }

    if (inverse) {
        for(let y=0;y<N;y++){
            let yr = N - 1 - y;
            for(let x=0;x<N;x++){
                let xr = N - 1 - x;
                let i1 = 2*(y*N+x);
                let i2 = 2*(yr*N+xr);
                field[i2]   = output[i1];
                field[i2+1] = output[i1+1];
            }
        }
        for(let i=0;i<2*N*N;i++){
            output[i] = field[i];
        }
    }
}

/* ---------- FFT (minimal, slow but clear) ---------- */
function fftshift2D(arr){
    let tmp = new Float32Array(arr.length);
    let h = N >> 1;
    for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
            let xs = (x + h) % N;
            let ys = (y + h) % N;
            let i1 = 2*(y*N + x);
            let i2 = 2*(ys*N + xs);
            tmp[i2]   = arr[i1];
            tmp[i2+1] = arr[i1+1];
            if (isNaN(tmp[i2]) || isNaN(tmp[i2+1])) {
                console.error("NaN detected at", xs, ys);
            }   
        }
    }
    arr.set(tmp);
}

function ifftshift2D(arr){
    // identical operation for even-sized arrays
    fftshift2D(arr);
}

function fft1d(re, im, inverse=false){
    const n = re.length;
    const pi = Math.PI;
    let j = 0;

    // Bit reversal
    for(let i=0;i<n;i++){
        if(i<j){
            [re[i],re[j]] = [re[j],re[i]];
            [im[i],im[j]] = [im[j],im[i]];
        }
        let m = n >> 1;
        while(j>=m && m>=2){
            j -= m;
            m >>= 1;
        }
        j += m;
    }

    // FFT stages
    for(let len=2;len<=n;len<<=1){
        let ang = 2*pi/len * (inverse?1:-1);
        let wlen_re = Math.cos(ang);
        let wlen_im = Math.sin(ang);

        for(let i=0;i<n;i+=len){
            let w_re = 1;
            let w_im = 0;
            for(let j=0;j<len/2;j++){
                let u_re = re[i+j];
                let u_im = im[i+j];
                let v_re = re[i+j+len/2]*w_re - im[i+j+len/2]*w_im;
                let v_im = re[i+j+len/2]*w_im + im[i+j+len/2]*w_re;

                re[i+j] = u_re + v_re;
                im[i+j] = u_im + v_im;
                re[i+j+len/2] = u_re - v_re;
                im[i+j+len/2] = u_im - v_im;

                let tmp = w_re*wlen_re - w_im*wlen_im;
                w_im = w_re*wlen_im + w_im*wlen_re;
                w_re = tmp;
            }
        }
    }

    // Normalize inverse FFT
    if(inverse){
        for(let i=0;i<n;i++){
            re[i] /= n;
            im[i] /= n;
        }
    }
}

function fft2(input,output,inverse=false){
    let re = new Float32Array(N*N);
    let im = new Float32Array(N*N);

    // Split complex
    for(let i=0;i<N*N;i++){
        re[i] = input[2*i];
        im[i] = input[2*i+1];
    }

    // FFT rows
    for(let y=0;y<N;y++){
        let row_re = new Float32Array(N);
        let row_im = new Float32Array(N);
        for(let x=0;x<N;x++){
            row_re[x] = re[y*N+x];
            row_im[x] = im[y*N+x];
        }
        fft1d(row_re,row_im,inverse);
        for(let x=0;x<N;x++){
            re[y*N+x] = row_re[x];
            im[y*N+x] = row_im[x];
        }
    }

    // FFT columns
    for(let x=0;x<N;x++){
        let col_re = new Float32Array(N);
        let col_im = new Float32Array(N);
        for(let y=0;y<N;y++){
            col_re[y] = re[y*N+x];
            col_im[y] = im[y*N+x];
        }
        fft1d(col_re,col_im,inverse);
        for(let y=0;y<N;y++){
            re[y*N+x] = col_re[y];
            im[y*N+x] = col_im[y];
        }
    }

    // Recombine
    for(let i=0;i<N*N;i++){
        output[2*i]   = re[i];
        output[2*i+1] = im[i];
    }
    const Mx = output.reduce((a, b) => Math.max(a, b), -Infinity);
    for(let i=0;i<2 * N*N;i++){
        output[i] *= 1/Mx ;
    }
}


/* ---------- Drawing ---------- */
function drawImage(canvas,data,scale=1){
    if (scale < 0) {
        const M = data.reduce((a, b) => Math.max(a, b), -Infinity);
        scale = 255.0 / M;
    }
    let ctx = canvas.getContext("2d");
    let img = ctx.createImageData(N,N);
    for(let i=0;i<N*N;i++){
        //let v = Math.min(255,Math.sqrt(data[i])*scale);
        let v = Math.min(255,data[i]*scale);
        img.data[4*i] = v;
        img.data[4*i+1] = v;
        img.data[4*i+2] = v;
        img.data[4*i+3] = 255;
    }
    ctx.putImageData(img,0,0);
}

function drawPhase(canvas,phase){
    let ctx = canvas.getContext("2d");
    let img = ctx.createImageData(N,N);
    for(let i=0;i<N*N;i++){
        let v = (phase[i]+Math.PI)/(2*Math.PI)*255;
        img.data[4*i] = v;
        img.data[4*i+1] = 0;
        img.data[4*i+2] = 255-v;
        img.data[4*i+3] = 255;
    }
    ctx.putImageData(img,0,0);
}

function drawDiff(canvas,Iorig,Icur){
    let df = new Float32Array(N*N);
    normOrig = 1.0 / Math.sqrt(Iorig.reduce((a, b) => a + b, 0));
    normCur = 1.0 / Math.sqrt(Icur.reduce((a, b) => a + b, 0));

    for(let i=0;i<N*N;i++) {
        df[i] = (Iorig[i] * normOrig - Icur[i] * normCur) * 1000;
    }
    const Mx = df.reduce((a, b) => Math.max(a, b), -Infinity);
    const Mn = df.reduce((a, b) => Math.min(a, b), Infinity);
    const absMax = Math.max(Math.abs(Mx), Math.abs(Mn));
    for(let i=0;i<N*N;i++) {
        df[i] = (df[i] - Mn) * 255.0 / absMax;
    }

    drawImage(canvas,df);
}

function drawAll(){
    drawImage(i1,I1, -1);
    drawImage(i2,I2, -1);
    drawImage(c1,S1, -1);
    drawImage(c2,S2, -1);
    drawPhase(p1,phase1);
    drawPhase(p2,phase2);
    drawDiff(d1,I1,S1);
    drawDiff(d2,I2,S2);
}
</script>

</body>
</html>
