<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectrum Bandwidth Tool</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; }
  .controls { margin-top: 10px; }
  input[type="number"] { width: 60px; }
</style>
</head>
<body>

<h2>Laser Spectrum Bandwidth</h2>
<div>
<label>
  Load directory:
<input type="file" id="fileDirectoryInput" accept=".csv">
</label>
</div>

<label>
  Load data files:
<input type="file" id="fileDataInput" accept=".csv" multiple>
</label>
<select id="inputSelect">
  <option value="Intensity">Intensity</option>
  <option value="DB">DB</option>
</select>
<div class="controls">
  dB level:
  <input type="number" id="dbInput" value="3" step="0.1">
  <button id="calcBtn">Calc</button>
</div>

<canvas id="plotBandWidth" width="900" height="400"></canvas>
<p>File: <input type="text" id="specFileName" size="40" readonly></p>
<p>Bandwidth: <input type="text" id="bwOutput" size="40" readonly></p>
<canvas id="plotSpectrum" width="900" height="400"></canvas>
<div id="dataTable"></div>

<script>
const canvasBandWidth = document.getElementById("plotBandWidth");
const ctxBandWidth = canvasBandWidth.getContext("2d");
const bandWidthScreeenPts = [];
const canvasSpectrum = document.getElementById("plotSpectrum");
const ctxSpectrum = canvasSpectrum.getContext("2d");

class spectrumData {
  constructor(fileName, gridsDistance) {
    this.fileName = fileName;
    this.gridsDistance = gridsDistance;
    this.freq = [];
    this.Iraw = [];
    this.Ismooth = [];
    this.bandWidth = null;
    this.IrawDb = [];
    this.IsmoothDb = [];
    this.bandWidthDb = null;
  }
}

let spectrums = [];
let crossings = null;
let threshold = null;
const inputSelect = document.getElementById("inputSelect");
let dataType = "Intensity";

// ---------- CSV parsing ----------
document.getElementById("fileDirectoryInput").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    parseDirectoryCSV(reader.result);
    fileDirectoryInput.value = "";
  };
  reader.readAsText(file);
});

function parseDirectoryCSV(text) {
  spectrums = [];


  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const cols = line.split(/[,;\t]/);
    if (cols.length < 2) continue;
    const distance = parseFloat(cols[1].trim());
    const filename = `W000${cols[0].trim()}.CSV`;
    if (!isNaN(distance) && filename) {
      spectrums.push(new spectrumData(filename, distance));
    }
  }
  console.log("Parsed directory CSV:", spectrums);
}

document.getElementById("fileDataInput").addEventListener("change", () => {
  const files = Array.from(fileDataInput.files);
  if (!files.length) return;

  files.forEach(file => {

    // âœ… filename condition
    const sIndex = spectrums.findIndex(s => s.fileName === file.name);
    if (sIndex < 0) {
      return;   // skip this file
    }

    const reader = new FileReader();

    reader.onload = () => {
      parseCSV(reader.result, sIndex);
    };

    reader.readAsText(file);
  });

  spectrums.sort((a, b) => a.gridsDistance - b.gridsDistance);

  // allow re-selecting same files again
  fileDataInput.value = "";
});

function parseCSV(text, sIndex) {
  spectrums[sIndex].freq = [];
  spectrums[sIndex].Iraw = [];
  spectrums[sIndex].Ismooth = [];
  spectrums[sIndex].IrawDb = [];
  spectrums[sIndex].IsmoothDb = [];
  crossings = null;

  const lines = text.split(/\r?\n/);
  let start = false;

  for (const line of lines) {
    const cols = line.split(/[,;\t]/);
    if (cols[0].trim().includes("[TRACE DATA]")) {
      start = true;
      continue;
    }
    if (!start) continue;
    if (cols.length < 2) continue;

    const f = parseFloat(cols[0]);
    const i = parseFloat(cols[1]);
    if (!isNaN(f) && !isNaN(i)) {
      spectrums[sIndex].freq.push(f);
      spectrums[sIndex].Iraw.push(Math.pow(10, i / 10)); // Convert dB to linear
      spectrums[sIndex].IrawDb.push(i);
    }
  }

  spectrums[sIndex].Ismooth = gaussianSmooth(spectrums[sIndex].Iraw, 3);
  spectrums[sIndex].IsmoothDb = gaussianSmooth(spectrums[sIndex].IrawDb, 3);
}

// ---------- Gaussian smoothing ----------
function gaussianSmooth(data, sigma) {
  const r = Math.ceil(3 * sigma);
  const kernel = [];
  let sum = 0;

  for (let k = -r; k <= r; k++) {
    const v = Math.exp(-(k * k) / (2 * sigma * sigma));
    kernel.push(v);
    sum += v;
  }
  for (let i = 0; i < kernel.length; i++) kernel[i] /= sum;

  const out = new Array(data.length).fill(0);
  for (let i = 0; i < data.length; i++) {
    for (let k = -r; k <= r; k++) {
      const j = i + k;
      if (j >= 0 && j < data.length) {
        out[i] += data[j] * kernel[k + r];
      }
    }
  }
  return out;
}

// ---------- Bandwidth calculation ----------
document.getElementById("calcBtn").addEventListener("click", () => {

//let listFreq = [], listIraw = [], listIsmooth = [];`
  if (!spectrums.length) return;
  spectrums.forEach(s => {
    s.bandWidth = calculateBandwidth(s, s.Iraw, s.Ismooth, "Intensity");
    s.bandWidthDb = calculateBandwidth(s, s.IrawDb, s.IsmoothDb, "DB");
  });

  const dataType = inputSelect.value;
  const Ismooth = dataType === "Intensity" ? spectrums[0].Ismooth : spectrums[0].IsmoothDb;
  const IRaw = dataType === "Intensity" ? spectrums[0].Iraw : spectrums[0].IrawDb;  
  calculateBandwidth(spectrums[0], IRaw, Ismooth, dataType);
  drawSpectrum(0, dataType); // Draw first spectrum by default
  drawBandWidth(dataType);
});

function calculateBandwidth(sp, Iraw, Ismooth, type) {
  if (!Ismooth.length) return;
  const freq = sp.freq;
  const dB = parseFloat(document.getElementById("dbInput").value);
  const imax = Math.max(...Ismooth);
  const ip = Ismooth.indexOf(imax);

  if (type === "DB") {
    threshold = imax - dB;
  } else {
    threshold = imax * Math.pow(10, -dB / 10);
  }

  let left = null, right = null;

  for (let i = ip; i > 0; i--) {
    if (Ismooth[i - 1] < threshold && Ismooth[i] >= threshold) {
      left = interp(freq, Ismooth, i - 1, i);
      break;
    }
  }

  for (let i = ip; i < Ismooth.length - 1; i++) {
    if (Ismooth[i] >= threshold && Ismooth[i + 1] < threshold) {
      right = interp(freq, Ismooth, i, i + 1);
      break;
    }
  }

  if (left && right) {
    crossings = { left, right };
    const bw = right.f - left.f;
    document.getElementById("bwOutput").value = `${bw.toPrecision(5)} (from ${left.f.toPrecision(7)} to ${right.f.toPrecision(7)})`;
    let str = "<table border='1'><tr><th>Frequency</th><th>Raw Intensity</th><th>Smoothed Intensity</th></tr>";
    for (let i = 0; i < freq.length; i++) {
      str += `<tr><td>${freq[i].toPrecision(7)}</td><td>${Iraw[i].toPrecision(7)}</td><td>${Ismooth[i].toPrecision(7)}</td></tr>`;
    }
    str += "</table>";
    document.getElementById("dataTable").innerHTML = str;
    document.getElementById("specFileName").value = sp.fileName;

    return bw;
  } else {
    document.getElementById("bwOutput").value = "N/A";
    crossings = null;
    return 0.0;
  }

}

function interp(freq, Ismooth, i1, i2) {
  const x1 = freq[i1], x2 = freq[i2];
  const y1 = Ismooth[i1], y2 = Ismooth[i2];
  const t = (threshold - y1) / (y2 - y1);
  return { f: x1 + t * (x2 - x1), I: threshold };
}

const marginPlot = 40;
// ---------- Plotting ----------
function findNearestPoint(screenPts, mx, my, radius) {
  let best = null;
  let bestP =- 1
  let bestDist2 = radius * radius;

  for (const p in screenPts) {
    const dx = screenPts[p].x - mx;
    const dy = screenPts[p].y - my;
    const d2 = dx * dx + dy * dy;
    if (d2 < bestDist2) {
      bestDist2 = d2;
      best = screenPts[p];
      bestP = p;
    }
  }
  return [best, bestP];
}

function drawMarker(canvas, ctx, p) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
  ctx.fill();
}

function drawTooltip(canvas, ctx, p, mx, my) {
  const text = `D = ${p.ox.toPrecision(6)} B = ${p.oy.toPrecision(4)}`;

  ctx.font = "12px Arial";
  const pad = 4;
  const w = ctx.measureText(text).width + 2 * pad;
  const h = 28;

  const tx = mx + 10;
  const ty = my - h - 10;

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.fillRect(tx, ty, w, h);

  ctx.strokeStyle = "#333";
  ctx.strokeRect(tx, ty, w, h);

  ctx.fillStyle = "#000";
  ctx.fillText(text, tx + pad, ty + 14);
}

canvasBandWidth.addEventListener("mousemove", e => {
  if (!bandWidthScreeenPts.length) return;
  const rect = canvasBandWidth.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const [hit, i] = findNearestPoint(bandWidthScreeenPts, mx, my, 25);
  drawBandWidth(inputSelect.value);
  if (hit) {
    drawMarker(canvasBandWidth, ctxBandWidth, hit);
    drawTooltip(canvasBandWidth, ctxBandWidth, hit, mx, my);
  }
});
canvasBandWidth.addEventListener("click", e => {
  if (!bandWidthScreeenPts.length) return;
  const rect = canvasBandWidth.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const [hit, i] = findNearestPoint(bandWidthScreeenPts, mx, my, 25);
  if (hit) {
    const dataType = inputSelect.value;
    const Ismooth = dataType === "Intensity" ? spectrums[i].Ismooth : spectrums[i].IsmoothDb;
    const IRaw = dataType === "Intensity" ? spectrums[i].Iraw : spectrums[i].IrawDb;
    calculateBandwidth(spectrums[i], IRaw, Ismooth, dataType);

    drawSpectrum(i, dataType); // Draw first spectrum by default
  } 
});

function scalesForPlots(canvas, margin, xData, yData) {
  const xmin = Math.min(...xData);
  const xmax = Math.max(...xData);
  const ymin = Math.min(...yData);
  const ymax = Math.max(...yData);

  const X = x => (x - xmin) / (xmax - xmin) * (canvas.width - 2 * margin) + margin;
  const Y = y => (canvas.height - 2 * margin) * (1 - (y - ymin) / (ymax - ymin)) + margin;

  return [X, Y];
}
function drawBandWidth(dataType) {
  const bw = dataType === "Intensity" ? spectrums.map(s => s.bandWidth) : spectrums.map(s => s.bandWidthDb);
  ctxBandWidth.clearRect(0, 0, canvasBandWidth.width, canvasBandWidth.height);
  plotGrid(canvasBandWidth, ctxBandWidth, spectrums.map(s => s.gridsDistance), bw, "lightgray");
  plotCurve(canvasBandWidth, ctxBandWidth, spectrums.map(s => s.gridsDistance), bw, "red", null, null, bandWidthScreeenPts);
}
function drawSpectrum(sIndex, type) {
  ctxSpectrum.clearRect(0, 0, canvasSpectrum.width, canvasSpectrum.height);
  if (!spectrums[sIndex].freq.length) return;

  const IRaw = type === "Intensity" ? spectrums[sIndex].Iraw : spectrums[sIndex].IrawDb;
  const ISmooth = type === "Intensity" ? spectrums[sIndex].Ismooth : spectrums[sIndex].IsmoothDb;

  const [X, Y] = scalesForPlots(canvasSpectrum, marginPlot, spectrums[sIndex].freq, IRaw);

  plotCurve(canvasSpectrum, ctxSpectrum, spectrums[sIndex].freq, IRaw, "red", X, Y);
  plotCurve(canvasSpectrum, ctxSpectrum, spectrums[sIndex].freq, ISmooth, "blue", X, Y);

  if (crossings) {
    ctxSpectrum.strokeStyle = "green";
    ctxSpectrum.beginPath();
    ctxSpectrum.moveTo(X(crossings.left.f), Y(threshold));
    ctxSpectrum.lineTo(X(crossings.right.f), Y(threshold));
    ctxSpectrum.stroke();
    drawCircle(canvasSpectrum, ctxSpectrum, X(crossings.left.f), Y(threshold));
    drawCircle(canvasSpectrum, ctxSpectrum, X(crossings.right.f), Y(threshold));
  }
}


function plotCurve(canvas, ctx, x, y, color, X = null, Y = null, screenPts = null) {
  if (X === null || Y === null) {
    [X, Y] = scalesForPlots(canvas, marginPlot, x, y);
  }
  if (screenPts) screenPts.length = 0;

  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i < x.length; i++) {
    const px = X(x[i]);
    const py = Y(y[i]);
    if (screenPts) screenPts.push({x: px, y: py, i, ox:x[i], oy:y[i]});
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.stroke();
}
function plotGrid(canvas, ctx, x, y, color) {
  const nGrid = 10;
  const mxx = Math.max(...x);
  const mnx = Math.min(...x);
  const mxy = Math.max(...y);
  const mny = Math.min(...y);
  const xGridStep = (mxx - mnx) / nGrid;
  const yGridStep = (mxy - mny) / nGrid;
  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.moveTo(px, marginPlot);
    ctx.lineTo(px, canvas.height - marginPlot);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.moveTo(marginPlot, py);
    ctx.lineTo(canvas.width - marginPlot, py);
  }
  ctx.stroke();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.fillText(gx.toFixed(2), px - 10, canvas.height - marginPlot + 15);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.fillText(gy.toFixed(3), marginPlot - 35, py + 5); 
  }
}

function drawCircle(canvas, ctx, x, y) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2 * Math.PI);
  ctx.fill();
}
</script>

</body>
</html>
