<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laser Beam M-Square Tool</title>
<style>
:root {
  --bg: #f6f8fa;
  --panel: #ffffff;
  --border: #d0d7de;
  --text: #24292f;
  --muted: #6e7781;
  --accent: #0969da;
  --danger: #cf222e;
  --ok: #1a7f37;
}

* {
  box-sizing: border-box;
}

body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  margin: 0;
  padding: 20px;
  background: var(--bg);
  color: var(--text);
}

/* Headings */
h2 {
  margin: 0 0 16px 0;
  font-size: 22px;
  font-weight: 600;
}

/* Panels / cards */
.panel {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

/* Layout */
.main-layout {
  display: flex;
  gap: 16px;
  align-items: flex-start;
}

.left-column {
  flex: 1;
  min-width: 500px;
}

.right-column {
  width: 550px;
  position: sticky;
  top: 16px;
}

/* Forms */
.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 12px;
}

.form-grid-long {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 12px;
}

label {
  display: flex;
  flex-direction: column;
  font-size: 12px;
  color: var(--muted);
}

input,
select,
button {
  margin-top: 4px;
  padding: 6px 8px;
  font-size: 13px;
  border-radius: 6px;
  border: 1px solid var(--border);
  background: white;
}

input[type="number"] {
  font-family: ui-monospace, SFMono-Regular, Consolas, monospace;
}

button {
  cursor: pointer;
  font-weight: 500;
  background: var(--accent);
  color: white;
  border: none;
}

button:hover {
  filter: brightness(1.05);
}

/* Canvas containers */
.canvas-panel {
  margin-top: 12px;
}

.canvas-panel h3 {
  font-size: 13px;
  font-weight: 600;
  margin: 0 0 6px 0;
  color: var(--muted);
}

canvas {
  display: block;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: #fff;
}

/* Tables */
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

th,
td {
  padding: 6px 8px;
  border-bottom: 1px solid var(--border);
  text-align: left;
  vertical-align: top;
}

tr:hover {
  background: #f0f3f6;
}

th {
  font-weight: 600;
  color: var(--muted);
}

.mono {
  font-family: ui-monospace, SFMono-Regular, Consolas, monospace;
  font-size: 11px;
}

/* Status colors */
.red { color: var(--danger); }
.green { color: var(--ok); }
.blue { color: var(--accent); }

/* Image preview row */
.image-row {
  display: flex;
  gap: 16px;
}
</style>


</head>
<body>
<script src="./UTIF.js"></script>
<div class="panel">
  <h2>Laser Beam M²</h2>
</div>

  <div class="main-layout">
    <div class="left-column">
      <div>
        <div class="panel">
          <div class="form-grid-long">
            <label>Builtin configuration:
              <select id="configs" name="configs" style="width:400px;" onchange="selectConfig();">
                <option value="1">P15 L7.5 P15 &lt;-&gt; P15 L15 P15 (Eden new configuration)</option>
                <option value="2">P10 L5 P10 &lt;-&gt; P10 L10 P10 (Yehuda new configuration)</option>
              </select>
            </label>
            <label>Near field width:
              <select id="nfWidth" name="nfWidth" style="width:400px;" onchange="selectConfig();">
                <option value="1">By Gaussian</option>
                <option value="2">By variance</option>
              </select>
            </label>
          </div>
        </div>
        <div class="panel">
          <div class="form-grid">
            <label>Camera pixel size (microns)<input type="number" id="dxMicrons" value="3.45" step="0.1"></label>
            <label>A <input type="number" id="aFactor" value="0" step="1"></label>
            <label>Focal length (cm) (B)<input type="number" id="dzCm" value="15" step="1"></label>
            <label>Wave length (nm)<input type="number" id="lamdaNm" value="1064" step="0.1"></label>
            <label>Sub factor<input type="number" id="subFactor" value="1" step="1"></label>
          </div>
        </div>
        <div class="panel">
          <div class="form-grid">
            <label>
              Load directory:
            <input type="file" id="fileDirectoryInput" accept=".csv">
            </label>
            <label>
              Load images:
            <input type="file" id="fileDataInput" accept=".tif,.png" multiple>
            </label>
          </div>
        </div>
      </div>

      <div class="controls">
        <button id="calcBtn">Calc</button>
      </div>
      <div class="canvas-panel">
        <h3>M² vs Distance</h3>
        <canvas id="plotM2" width="900" height="400"></canvas>
      </div>
      <p>File: <input type="text" id="m2FileName" size="20" readonly></p>
      <p>M2: <input type="text" id="m2Output" size="20" readonly></p>
      <div class="canvas-panel">
        <h3>Intensity vs Distance</h3>
        <div><canvas id="plotLines" width="900" height="400"></canvas></div>
      </div>
      <div class="canvas-panel">
        <h3>Log intensity vs Distance</h3>
        <div><canvas id="plotLogLines" width="900" height="400"></canvas></div>
      </div>
    </div>
    
    <div  class="right-column" style="position: sticky; top: 10px">
      <div id="dataTable"></div>
      <div id="tableFiles"></div>
    </div>
  </div>
</div>
<div>
  <div style="display: flex; flex-direction: row; gap: 10px;">
  <canvas id="imageNear" width="400" height="400"></canvas>
  <canvas id="imageFar" width="400" height="400"></canvas>
  </div>
</div>
<script>
const canvasM2 = document.getElementById("plotM2");
const ctxM2 = canvasM2.getContext("2d");
const M2ScreeenPts = [];
const canvasLines = document.getElementById("plotLines");
const canvasLogLines = document.getElementById("plotLogLines");
const ctxLines = canvasLines.getContext("2d");
const ctxLogLines = canvasLogLines.getContext("2d");

class imagePairData {
  constructor(fileLabel, gridsDistance) {
    this.fileLabel = fileLabel;
    this.gridsDistance = gridsDistance;
    this.fileNameNear = "-";
    this.imageNear = null;
    this.yNear = -1;
    this.lineNear = [];
    this.lineCleanNear = [];
    this.nearGaussianMatch = null;
    this.statNear = [];
    this.fileNameFar = "-";
    this.imageFar = null;
    this.yFear = -1;
    this.lineFar = [];
    this.lineCleanFar = [];
    this.statFar = [];
    this.M2 = [0, 0];
    this.addedData = [];
  }
}

let imagePairs = [];
let crossings = null;
let threshold = null;
const inputSelect = document.getElementById("inputSelect");

function selectConfig() {
  switch (document.getElementById("configs").value) {
    case "1":
      document.getElementById("dxMicrons").value = "3.45";
      document.getElementById("dzCm").value = "15";
      document.getElementById("aFactor").value = "0";
      document.getElementById("lamdaNm").value = "1064";
      break;    
    case "2":
      document.getElementById("dxMicrons").value = "5.2";
      document.getElementById("dzCm").value = "10";
      document.getElementById("aFactor").value = "0";
      document.getElementById("lamdaNm").value = "1064";
      break;    
  }
}
// ---------- CSV parsing ----------
document.getElementById("fileDirectoryInput").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    parseDirectoryCSV(reader.result);
    fileDirectoryInput.value = "";
  };
  reader.readAsText(file);
});

function parseDirectoryCSV(text) {
  imagePairs = [];

  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const cols = line.split(/[,;\t]/);
    if (cols.length < 2) continue;
    const distance = parseFloat(cols[1].trim());
    const fileLabel = cols[0].trim();
    if (!isNaN(distance) && fileLabel) {
      imagePairs.push(new imagePairData(fileLabel, distance));
      for (let col = 2; col < cols.length; col++) {
        imagePairs.addedData.push(parseFloat(cols[col].trim()));
      }
    }
  }
  imagePairs.sort((a, b) => a.gridsDistance - b.gridsDistance);

  displayFiles();

  console.log("Parsed directory CSV:", imagePairs);
}

// ---------- image file processing ----------
function matchLabel(t, l, name) {
    return name.toLowerCase().includes(t) && name.includes(l);
}

function readImageData(file) {
    if (file.name.includes(".tif")) {
      return readTiffData(file);
    }
    return new Promise((resolve, reject) => {
        const img = new Image();

        img.src = URL.createObjectURL(file);
        
        img.onload = () => {
            const canvas = new OffscreenCanvas(img.width, img.height);
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            console.log("Original image size:", imageData.width, imageData.height);
            resolve(imageData);
        };
        img.onerror = reject;
    });
}

async function readTiffData(file) {
  const buffer = await file.arrayBuffer();

  const ifds = UTIF.decode(buffer);
  UTIF.decodeImage(buffer, ifds[0]);

  const rgba = UTIF.toRGBA8(ifds[0]); // Uint8Array [R,G,B,A,...]
  const w = ifds[0].width;
  const h = ifds[0].height;

  const canvas = new OffscreenCanvas(w, h);
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, w, h);
  for (let i = 0; i < rgba.length; i += 4) {
    imageData.data[i] = rgba[i];
    imageData.data[i + 1] = rgba[i + 1];
    imageData.data[i + 2] = rgba[i + 2];
    imageData.data[i + 3] = 255;
  }


  return imageData;
}

function extractBestImageLine(img) {
    let line = [];
    let maxIntens = - 1;
    let bestY = - 1;
    for (let y = 0; y < img.height; y++) {
        let lineIntens = 0;
        for (let x = 0; x < img.width; x++) {
            let w = (img.width - x) * (img.width - x);
            const srcIndex = 4 * (y * img.width + x);
            lineIntens += img.data[srcIndex] * w;
        }
        if (maxIntens < lineIntens) {
            maxIntens = lineIntens;
            bestY = y;
        }
    }
    if (bestY >= 0) {
        for (let x = 0; x < img.width; x++) {
            const srcIndex = 4 * (bestY * img.width + x);
            line.push(img.data[srcIndex]);
        }
       
    }
    return [line, bestY];
}

document.getElementById("fileDataInput").addEventListener("change", () => {
  const files = Array.from(fileDataInput.files);
  if (!files.length) return;

  displayFiles();
  
  files.forEach(file => {

    // ✅ filename condition
    const sNearIndex = imagePairs.findIndex(s => matchLabel("near", s.fileLabel, file.name));
    const sFarIndex = imagePairs.findIndex(s => matchLabel("far", s.fileLabel, file.name));
    if (sNearIndex < 0 && sFarIndex < 0) {
      return;   // skip this file
    }

    readImageData(file).then(img => {
        if (sNearIndex >= 0) {
            imagePairs[sNearIndex].fileNameNear = file.name;
            imagePairs[sNearIndex].imageNear = img;
            [imagePairs[sNearIndex].lineNear, imagePairs[sNearIndex].yNear] = extractBestImageLine(img)
            imagePairs[sNearIndex].lineCleanNear = subtractBackground(imagePairs[sNearIndex].lineNear)
            
        } else if (sFarIndex >= 0) {
            imagePairs[sFarIndex].fileNameFar = file.name;
            imagePairs[sFarIndex].imageFar = img;
            [imagePairs[sFarIndex].lineFar, imagePairs[sFarIndex].yFar] = extractBestImageLine(img);
            imagePairs[sFarIndex].lineCleanFar = subtractBackground(imagePairs[sFarIndex].lineFar)
        }
        displayFiles();
    });

  });

  // allow re-selecting same files again
  fileDataInput.value = "";
});


// ---------- M2 calculation ----------
/**
 * Compute 1D second-moment beam radius (ISO 11146)
 * @param {Float32Array|Float64Array} I  intensity line
 * @param {number} dx  pixel size [meters]
 * @returns {number} beam radius w [meters]
 */
function secondMomentRadius(I, dx) {
    let sumI = 0;
    let sumX = 0;
    let sumX2 = 0;

    for (let i = 0; i < I.length; i++) {
        const x = i * dx;
        const v = I[i];
        sumI += v;
        sumX += v * x;
        sumX2 += v * x * x;
    }

    const xbar = sumX / sumI;
    const variance = sumX2 / sumI - xbar * xbar;

    // ISO definition: w = sqrt(2 * variance)
    return [Math.sqrt(2 * variance), xbar, sumI];
}

function computeM(w1, w2, A, B, lambda) {
  if (w2 <= w1 || w2 < Math.abs(A) * w1) {
      return -1;
  }
  const M2 = Math.PI * w1 / (lambda * B) * Math.sqrt(w2 * w2 - A * A * w1 * w1);
  return M2;
}
/**
 * Compute M² from two beam profiles
 *
 * @param {TypedArray} I1  near-field intensity line
 * @param {TypedArray} I2  far-field intensity line
 * @param {number} dx      pixel size [meters]
 * @param {number} dz      propagation distance [meters]
 * @param {number} lambda  wavelength [meters]
 * @returns {number} M²
 */
function computeMSquared(nearGaussianMatch, I1, I2, dx, dz, lambda, aFactor) {
    const stats1 = secondMomentRadius(I1, dx);
    const stats2 = secondMomentRadius(I2, dx);

    const w1 = stats1[0];
    const w2 = stats2[0];
    const w1G = nearGaussianMatch.sigma * Math.sqrt(2.0) * 2.0 * dx;

    const A = aFactor;
    const B = dz;

    const M2 = computeM(w1, w2, A, B, lambda);
    const M2G = computeM(w1G, w2, A, B, lambda);

    return [[M2, M2G], stats1, stats2];
}

function calculateM2(pair) {

  pair.lineCleanNear = subtractBackground(pair.lineNear);
  pair.lineCleanFar = subtractBackground(pair.lineFar);
  pair.nearGaussianMatch = matchGaussian(pair.lineNear);
  const dxMicrons = parseFloat(document.getElementById("dxMicrons").value.trim());
  const dzCm = parseFloat(document.getElementById("dzCm").value.trim());
  const aFactor = parseFloat(document.getElementById("aFactor").value.trim());
  const lamdaNm = parseFloat(document.getElementById("lamdaNm").value.trim());
  
  const rc = computeMSquared(pair.nearGaussianMatch, pair.lineCleanNear, pair.lineCleanFar, dxMicrons * 1E-06, dzCm * 0.01, lamdaNm * 1E-09, aFactor);
  
  pair.M2 = rc[0];
  for (let i = 0; i < 3; i++) {
    pair.statNear[i] = rc[1][i];
    pair.statFar[i] = rc[2][i];
  }
}

document.getElementById("calcBtn").addEventListener("click", () => {

  if (!imagePairs.length) return;
  imagePairs.forEach(p => {
    calculateM2(p);
  });

  displayFiles();
  drawSingle(0);
  drawM2();
});

function displayFileData(i, s) {
  const dxMicrons = parseFloat(document.getElementById("dxMicrons").value.trim());
  return `
        <tr onclick="drawSingle(${i});">
          <td>${s.fileLabel}</td>
          <td>${s.gridsDistance}</td>
          <td class="mono">${s.fileNameNear}<br>${s.fileNameFar}</td>
          <td>
            <span class="red">${s.M2[0].toFixed(3)}</span>
            <br>
            <span class="green">${s.M2[1].toFixed(3)}</span>
          </td>
          <td>
            <span class="red">${(s.statNear[0]*1000).toFixed(3)}</span>
            <span class="blue">${(s.statFar[0]*1000).toFixed(3)}</span>
            <br>
            <span class="green">
              ${s.nearGaussianMatch
                ? (s.nearGaussianMatch.sigma * 2 * Math.sqrt(2) * dxMicrons / 1000).toFixed(3)
                : ""}
            </span>
          </td>
        </tr>`;
}
function displayFiles() {
  document.getElementById("tableFiles").innerHTML = 
    `<table><tr><td>Label</td><td>Distance</td><td>Files</td><td>M²</td><td>Widths (mm)</td></tr>${imagePairs.map((s, i) => displayFileData(i, s)).join('')}</table>`;
}
const marginPlot = 40;
// ---------- Plotting ----------
function findNearestPoint(screenPts, mx, my, radius) {
  let best = null;
  let bestP =- 1
  let bestDist2 = radius * radius;

  for (const p in screenPts) {
    const dx = screenPts[p].x - mx;
    const dy = screenPts[p].y - my;
    const d2 = dx * dx + dy * dy;
    if (d2 < bestDist2) {
      bestDist2 = d2;
      best = screenPts[p];
      bestP = p;
    }
  }
  return [best, bestP];
}

function drawMarker(canvas, ctx, p) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
  ctx.fill();
}

function drawTooltip(canvas, ctx, p, mx, my) {
  const text = `D = ${p.ox.toPrecision(6)} B = ${p.oy.toPrecision(4)}`;

  const oldFont = ctx.font;
  ctx.font = "12px Arial";
  const pad = 4;
  const w = ctx.measureText(text).width + 2 * pad;
  const h = 28;

  const tx = mx + 10;
  const ty = my - h - 10;

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.fillRect(tx, ty, w, h);

  ctx.strokeStyle = "#333";
  ctx.strokeRect(tx, ty, w, h);

  ctx.fillStyle = "#000";
  ctx.fillText(text, tx + pad, ty + 14);
  ctx.font = oldFont;
}

canvasM2.addEventListener("mousemove", e => {
  if (!M2ScreeenPts.length) return;
  const rect = canvasM2.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const [hit, i] = findNearestPoint(M2ScreeenPts, mx, my, 25);
  drawM2();
  if (hit) {
    drawMarker(canvasM2, ctxM2, hit);
    drawTooltip(canvasM2, ctxM2, hit, mx, my);
  }
});
canvasM2.addEventListener("click", e => {
  if (!M2ScreeenPts.length) return;
  const rect = canvasM2.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  let [hit, i] = findNearestPoint(M2ScreeenPts, mx, my, 25);
  if (i > imagePairs.length) {
    i = i % imagePairs.length;
  }
  if (hit) {
    calculateM2(imagePairs[i]);

    drawSingle(i); // Draw first spectrum by default
  } 
});

function scalesForPlots(canvas, margin, xData, yData) {
  const xmin = Math.min(...xData);
  const xmax = Math.max(...xData);
  const ymin = Math.min(...yData);
  const ymax = Math.max(...yData);

  const X = x => (x - xmin) / (xmax - xmin) * (canvas.width - 2 * margin) + margin;
  const Y = y => (canvas.height - 2 * margin) * (1 - (y - ymin) / (ymax - ymin)) + margin;

  return [X, Y];
}
function drawM2() {
  const gd = imagePairs.map(s => s.gridsDistance);
  const m2 = imagePairs.map(s => s.M2[0]);
  const m2G = imagePairs.map(s => s.M2[1]);
  const power = imagePairs.map(s => s.nearGaussianMatch.power * 100.0);
  const [X, Y] = scalesForPlots(canvasM2, marginPlot, gd, [...m2, ...m2G]);

  ctxM2.clearRect(0, 0, canvasM2.width, canvasM2.height);
  plotGrid(canvasM2, ctxM2, gd, [...m2, ...m2G], "lightgray");
  plotCurve(canvasM2, ctxM2, gd, m2, "red", X, Y, M2ScreeenPts);
  const M2GScreeenPts = []
  plotCurve(canvasM2, ctxM2, gd, m2G, "green", X, Y, M2GScreeenPts);
  M2ScreeenPts.push(...M2GScreeenPts);
  plotHistogram(canvasM2, ctxM2, gd, power, "#00ff0080", X, Y);
}

function drawSingle(i) {
  drawLines(i);
  let canvas = document.getElementById("imageNear");
  canvas.width = imagePairs[i].imageNear.width;
  canvas.height = imagePairs[i].imageNear.height;
  let ctx = canvas.getContext("2d");
  ctx.putImageData(imagePairs[i].imageNear,0,0);
  ctx.strokeStyle = "red";
  ctx.beginPath();
  ctx.moveTo(0, imagePairs[i].yNear);
  ctx.lineTo(canvas.width, imagePairs[i].yNear);
  ctx.stroke();
  canvas = document.getElementById("imageFar");
  canvas.width = imagePairs[i].imageFar.width;
  canvas.height = imagePairs[i].imageFar.height;
  ctx = canvas.getContext("2d");
  ctx.putImageData(imagePairs[i].imageFar,0,0);
  ctx.strokeStyle = "blue";
  ctx.beginPath();
  ctx.moveTo(0, imagePairs[i].yFar);
  ctx.lineTo(canvas.width, imagePairs[i].yFar);
  ctx.stroke();

  document.getElementById("m2FileName").value = imagePairs[i].fileLabel;
  document.getElementById("m2Output").value = imagePairs[i].M2[0].toFixed(3);

}

function logNorm(x) {
  const f = 0.5 / Math.max(...x);;
  return x.map(v => - Math.sqrt(- Math.log(v *f + 0.0000001)) );
  //return x.map(v => Math.log(v *f + 0.0000001)) ;
}
function drawLines(i) {
  ctxLines.clearRect(0, 0, canvasLines.width, canvasLines.height);
  ctxLogLines.clearRect(0, 0, canvasLogLines.width, canvasLogLines.height);
  const dxMicrons = parseFloat(document.getElementById("dxMicrons").value.trim());
  const dxMM = dxMicrons * 1E-03;
  const pair = imagePairs[i];
  if (!pair.lineNear.length || !pair.lineFar.length) return;

  const xVec = pair.lineNear.map((v, i) => i * dxMM);

  const loglineNear = logNorm(pair.lineNear);
  const loglineFar = logNorm(pair.lineFar);
  const [X, Y] = scalesForPlots(canvasLines, marginPlot, xVec, pair.lineNear);
  const [logX, logY] = scalesForPlots(canvasLogLines, marginPlot, xVec, loglineNear);

  plotGrid(canvasLines, ctxLines, xVec, pair.lineNear, "lightgray");

  plotCurve(canvasLines, ctxLines, xVec, pair.lineNear, "#ffaaaa", X, Y);
  plotCurve(canvasLines, ctxLines, xVec, pair.lineFar, "#aaaaff", X, Y);
  plotCurve(canvasLines, ctxLines, xVec, pair.lineCleanNear, "red", X, Y);
  if (pair.nearGaussianMatch) {
    plotCurve(canvasLines, ctxLines, xVec, pair.nearGaussianMatch.fit, "green", X, Y);
  }
  plotCurve(canvasLines, ctxLines, xVec, pair.lineCleanFar, "blue", X, Y);

  plotGrid(canvasLogLines, ctxLogLines, xVec, loglineNear, "lightgray");
  plotCurve(canvasLogLines, ctxLogLines, xVec, loglineNear, "red", logX, logY);
  plotCurve(canvasLogLines, ctxLogLines, xVec, loglineFar, "blue", logX, logY);

  if (pair.statNear.length >= 3) {
      ctxLines.strokeStyle = "red";
      ctxLines.beginPath();
      let sx = (pair.statNear[1] - 0.5 * pair.statNear[0]) * 1000;
      let ex = (pair.statNear[1] + 0.5 * pair.statNear[0]) * 1000;
      ctxLines.moveTo(X(sx), canvasLines.height / 2);
      ctxLines.lineTo(X(ex), canvasLines.height / 2);
      ctxLines.stroke();
  }
  if (pair.statFar.length >= 3) {
      ctxLines.strokeStyle = "blue";
      ctxLines.beginPath();
      let sx = (pair.statFar[1] - 0.5 * pair.statFar[0]) * 1000;
      let ex = (pair.statFar[1] + 0.5 * pair.statFar[0]) * 1000;
      ctxLines.moveTo(X(sx), canvasLines.height / 2 - 10);
      ctxLines.lineTo(X(ex), canvasLines.height / 2 - 10);
      ctxLines.stroke();
  }

  if (pair.nearGaussianMatch) {
      ctxLines.strokeStyle = "green";
      ctxLines.beginPath();
      let sx = (pair.nearGaussianMatch.x0 - pair.nearGaussianMatch.sigma * Math.sqrt(2.0)) * dxMM;
      let ex = (pair.nearGaussianMatch.x0 + pair.nearGaussianMatch.sigma * Math.sqrt(2.0)) * dxMM;
      ctxLines.moveTo(X(sx), canvasLines.height / 2 + 10);
      ctxLines.lineTo(X(ex), canvasLines.height / 2 + 10);
      ctxLines.stroke();
  }
}


function plotCurve(canvas, ctx, x, y, color, X = null, Y = null, screenPts = null) {
  if (X === null || Y === null) {
    [X, Y] = scalesForPlots(canvas, marginPlot, x, y);
  }
  if (screenPts) screenPts.length = 0;

  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i < x.length; i++) {
    const px = X(x[i]);
    const py = Y(y[i]);
    if (screenPts) screenPts.push({x: px, y: py, i, ox:x[i], oy:y[i]});
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.stroke();
}

function plotHistogram(canvas, ctx, x, y, color, X, Y) {
  const oldFont = ctx.font;
  ctx.font = "8px Arial";
  for (let i = 0; i < x.length; i++) {
    const px = X(x[i]);
    const py = y[i];
    ctx.fillStyle = color;
    ctx.fillRect(px - 6, canvas.height - marginPlot - py, 12, py);
    ctx.fillStyle = "black";
    ctx.fillText(Math.round(py).toString(), px - 5, canvas.height - marginPlot - py + 12);
  }
  ctx.font = oldFont;

}

function plotGrid(canvas, ctx, x, y, color) {
  const nGrid = 10;
  const mxx = Math.max(...x);
  const mnx = Math.min(...x);
  const mxy = Math.max(...y);
  const mny = Math.min(...y);
  const xGridStep = (mxx - mnx) / nGrid;
  const yGridStep = (mxy - mny) / nGrid;
  ctx.strokeStyle = color;
  ctx.fillStyle = "black";
  ctx.beginPath();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.moveTo(px, marginPlot);
    ctx.lineTo(px, canvas.height - marginPlot);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.moveTo(marginPlot, py);
    ctx.lineTo(canvas.width - marginPlot, py);
  }
  ctx.stroke();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.fillText(gx.toFixed(2), px - 10, canvas.height - marginPlot + 15);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.fillText(gy.toFixed(3), marginPlot - 35, py + 5); 
  }
}

function drawCircle(canvas, ctx, x, y) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2 * Math.PI);
  ctx.fill();
}

/**
 * Robust background subtraction for 1D beam profile
 *
 * @param {Float32Array|Float64Array} I
 * @param {number} centralFraction  fraction of profile width to ignore (0.3 is typical)
 * @returns {{signal: Float32Array, background: number}}
 */
function subtractBackground(I, centralFraction = 0.3) {
    const N = I.length;

    // --- rough centroid (no bg removal yet)
    let sumI = 0, sumX = 0;
    for (let i = 0; i < N; i++) {
        sumI += I[i];
        sumX += I[i] * i;
    }
    const xc = sumX / sumI;

    // --- define exclusion window
    const halfWidth = Math.floor(N * centralFraction / 2);
    const iMin = Math.max(0, Math.floor(xc - halfWidth));
    const iMax = Math.min(N, Math.floor(xc + halfWidth));

    // --- collect background samples
    const bgSamples = [];
    for (let i = 0; i < N; i++) {
        if (i < iMin || i > iMax) {
            bgSamples.push(I[i]);
        }
    }

    // --- robust estimator: median
    bgSamples.sort((a, b) => a - b);
    const mid = Math.floor(bgSamples.length / 2);
    const background =
        bgSamples.length % 2
            ? bgSamples[mid]
            : 0.5 * (bgSamples[mid - 1] + bgSamples[mid]);

    const subFactor = parseFloat(document.getElementById("subFactor").value.trim());
    // --- subtract and clamp
    const out = new Float32Array(N);
    for (let i = 0; i < N; i++) {
        out[i] = Math.max(I[i] - subFactor * background, 0);
    }

    return out;
    //return { signal: out, background };
}

function gaussianCouplingEfficiency(y, gaussian) {
    const { x0, sigma, B } = gaussian;
    const N = y.length;

    let num = 0;
    let denomSignal = 0;
    let denomGauss = 0;

    const w = Math.sqrt(2) * sigma;

    for (let i = 0; i < N; i++) {
        const I = Math.max(0, y[i] - B);
        const E = Math.sqrt(I);
        const G = Math.exp(-((i - x0) ** 2) / (w * w));

        num += E * G;
        denomSignal += I;
        denomGauss += G * G;
    }

    const eta = (num * num) / (denomSignal * denomGauss);
    return Math.min(Math.max(eta, 0), 1);
}

function matchGaussian(y, options = {}) {
    const N = y.length;

    // ---------- parameters
    const sigmaMin = options.sigmaMin ?? 2;
    const sigmaMax = options.sigmaMax ?? 80;
    const sigmaSteps = options.sigmaSteps ?? 60;

    // ---------- background removal
    const sorted = [...y].sort((a, b) => a - b);
    const B = sorted[Math.floor(0.1 * N)];
    const s = y.map(v => Math.max(0, v - B));

    // ---------- peak estimate
    let peak = 0;
    let normS = 0.0
    for (let i = 1; i < N; i++) {
        normS += s[i] * s[i];
        if (s[i] > s[peak]) peak = i;
    }
    normS = Math.sqrt(normS)

    let best = {
        score: -Infinity,
        x0: peak,
        sigma: sigmaMin
    };

    // ---------- precompute x
    const x = [...Array(N).keys()];

    // ---------- scan parameters
    for (let k = 0; k < sigmaSteps; k++) {
        const sigma =
            sigmaMin * Math.pow(sigmaMax / sigmaMin, k / (sigmaSteps - 1));

        const inv2s2 = 1 / (2 * sigma * sigma);

        for (let x0 = peak - 40; x0 <= peak + 40; x0++) {
            if (x0 < 0 || x0 >= N) continue;

            let dot = 0;
            let normG = 0;

            for (let i = 0; i < N; i++) {
                const g = Math.exp(-((i - x0) ** 2) * inv2s2);
                dot += s[i] * g;
                normG += g * g;
            }

            const score = dot / Math.sqrt(normG);

            if (score > best.score) {
                best = { score, x0, sigma };
            }
        }
    }

    // ---------- amplitude (least squares)
    let num = 0, den = 0;
    for (let i = 0; i < N; i++) {
        const g = Math.exp(-((i - best.x0) ** 2) / (2 * best.sigma ** 2));
        num += s[i] * g;
        den += g * g;
    }
    const A = num / den;

    // ---------- fitted curve
    const fit = x.map(i =>
        B + A * Math.exp(-((i - best.x0) ** 2) / (2 * best.sigma ** 2))
    );

    const power = gaussianCouplingEfficiency(y, {x0: best.x0, sigma: best.sigma, B});
    return {
        x0: best.x0,
        sigma: best.sigma,
        A,
        B,
        score: best.score / normS,
        power,
        fit
    };
}

</script>

</body>
</html>
