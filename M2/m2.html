<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laser Beam M-Square Tool</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; }
  .controls { margin-top: 10px; }
  input[type="number"] { width: 60px; }
</style>

</head>
<body>
<script src="./UTIF.js"></script>
<script>
  console.log(UTIF); // should work
</script>

<h2>Laser Beam M-Square</h2>
<div>
  <div style="display: flex; flex-direction: row; gap: 10px; align-items: self-start;">
    <div>
      <div>
        <div>
        <label>Builtin configuration:
          <select id="configs" name="configs" onchange="selectConfig();">
            <option value="1">P15 L7.5 P15 &lt;-&gt; P15 L15 P15 (Eden new configuration)</option>
            <option value="2">Banana</option>
            <option value="3">Cherry</option>
          </select>
        </label>
        </div>
        <label>Camera pixel size (microns)<input type="number" id="dxMicrons" value="3.45" step="0.1"></label>
        <label>A <input type="number" id="aFactor" value="0" step="1"></label>
        <label>Focal length (cm) (B)<input type="number" id="dzCm" value="15" step="1"></label>
        <label>Wave length (nm)<input type="number" id="lamdaNm" value="1064" step="0.1"></label>
      </div>
      <div>
        <label>Sub factor<input type="number" id="subFactor" value="1" step="1"></label>
      </div>
      <div>
        <label>
          Load directory:
        <input type="file" id="fileDirectoryInput" accept=".csv">
        </label>
      </div>

      <label>
        Load images:
      <input type="file" id="fileDataInput" accept=".tif,.png" multiple>
      </label>
      <div class="controls">
        <button id="calcBtn">Calc</button>
      </div>
      <canvas id="plotM2" width="900" height="400"></canvas>
      <p>File: <input type="text" id="m2FileName" size="20" readonly></p>
      <p>M2: <input type="text" id="m2Output" size="20" readonly></p>
      <div><canvas id="plotLines" width="900" height="400"></canvas></div>
      <div><canvas id="plotLogLines" width="900" height="400"></canvas></div>
    </div>
    
    <div style="position: sticky; top: 10px">
      <div id="dataTable"></div>
      <div id="tableFiles"></div>
    </div>
  </div>
</div>
<div>
  <div style="display: flex; flex-direction: row; gap: 10px;">
  <canvas id="imageNear" width="400" height="400"></canvas>
  <canvas id="imageFar" width="400" height="400"></canvas>
  </div>
</div>
<script>
const canvasM2 = document.getElementById("plotM2");
const ctxM2 = canvasM2.getContext("2d");
const M2ScreeenPts = [];
const canvasLines = document.getElementById("plotLines");
const canvasLogLines = document.getElementById("plotLogLines");
const ctxLines = canvasLines.getContext("2d");
const ctxLogLines = canvasLogLines.getContext("2d");

class imagePairData {
  constructor(fileLabel, gridsDistance) {
    this.fileLabel = fileLabel;
    this.gridsDistance = gridsDistance;
    this.fileNameNear = "-";
    this.imageNear = null;
    this.yNear = -1;
    this.lineNear = [];
    this.lineCleanNear = [];
    this.nearGaussianMatch = null;
    this.statNear = [];
    this.fileNameFar = "-";
    this.imageFar = null;
    this.yFear = -1;
    this.lineFar = [];
    this.lineCleanFar = [];
    this.statFar = [];
    this.M2 = 0.0;
  }
}

let imagePairs = [];
let crossings = null;
let threshold = null;
const inputSelect = document.getElementById("inputSelect");

function selectConfig() {
  switch (document.getElementById("configs").value) {
    case "1":
      document.getElementById("dxMicrons").value = "3.45";
      document.getElementById("dzCm").value = "15";
      document.getElementById("aFactor").value = "0";
      document.getElementById("lamdaNm").value = "1064";
      break;    
  }
}
// ---------- CSV parsing ----------
document.getElementById("fileDirectoryInput").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    parseDirectoryCSV(reader.result);
    fileDirectoryInput.value = "";
  };
  reader.readAsText(file);
});

function parseDirectoryCSV(text) {
  imagePairs = [];

  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const cols = line.split(/[,;\t]/);
    if (cols.length < 2) continue;
    const distance = parseFloat(cols[1].trim());
    const fileLabel = cols[0].trim();
    if (!isNaN(distance) && fileLabel) {
      imagePairs.push(new imagePairData(fileLabel, distance));
    }
  }
  imagePairs.sort((a, b) => a.gridsDistance - b.gridsDistance);

  displayFiles();

  console.log("Parsed directory CSV:", imagePairs);
}

// ---------- image file processing ----------
function matchLabel(t, l, name) {
    return name.toLowerCase().includes(t) && name.includes(l);
}

function readImageData(file) {
    if (file.name.includes(".tif")) {
      return readTiffData(file);
    }
    return new Promise((resolve, reject) => {
        const img = new Image();

        img.src = URL.createObjectURL(file);
        
        img.onload = () => {
            const canvas = new OffscreenCanvas(img.width, img.height);
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            console.log("Original image size:", imageData.width, imageData.height);
            resolve(imageData);
        };
        img.onerror = reject;
    });
}

async function readTiffData(file) {
  const buffer = await file.arrayBuffer();

  const ifds = UTIF.decode(buffer);
  UTIF.decodeImage(buffer, ifds[0]);

  const rgba = UTIF.toRGBA8(ifds[0]); // Uint8Array [R,G,B,A,...]
  const w = ifds[0].width;
  const h = ifds[0].height;

  const canvas = new OffscreenCanvas(w, h);
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, w, h);
  for (let i = 0; i < rgba.length; i += 4) {
    imageData.data[i] = rgba[i];
    imageData.data[i + 1] = rgba[i + 1];
    imageData.data[i + 2] = rgba[i + 2];
    imageData.data[i + 3] = 255;
  }


  return imageData;
}

function extractBestImageLine(img) {
    let line = [];
    let maxIntens = - 1;
    let bestY = - 1;
    for (let y = 0; y < img.height; y++) {
        let lineIntens = 0;
        for (let x = 0; x < img.width; x++) {
            let w = (img.width - x) * (img.width - x);
            const srcIndex = 4 * (y * img.width + x);
            lineIntens += img.data[srcIndex] * w;
        }
        if (maxIntens < lineIntens) {
            maxIntens = lineIntens;
            bestY = y;
        }
    }
    if (bestY >= 0) {
        for (let x = 0; x < img.width; x++) {
            const srcIndex = 4 * (bestY * img.width + x);
            line.push(img.data[srcIndex]);
        }
       
    }
    return [line, bestY];
}

document.getElementById("fileDataInput").addEventListener("change", () => {
  const files = Array.from(fileDataInput.files);
  if (!files.length) return;

  displayFiles();
  
  files.forEach(file => {

    // ✅ filename condition
    const sNearIndex = imagePairs.findIndex(s => matchLabel("near", s.fileLabel, file.name));
    const sFarIndex = imagePairs.findIndex(s => matchLabel("far", s.fileLabel, file.name));
    if (sNearIndex < 0 && sFarIndex < 0) {
      return;   // skip this file
    }

    readImageData(file).then(img => {
        if (sNearIndex >= 0) {
            imagePairs[sNearIndex].fileNameNear = file.name;
            imagePairs[sNearIndex].imageNear = img;
            [imagePairs[sNearIndex].lineNear, imagePairs[sNearIndex].yNear] = extractBestImageLine(img)
            imagePairs[sNearIndex].lineCleanNear = subtractBackground(imagePairs[sNearIndex].lineNear)
            
        } else if (sFarIndex >= 0) {
            imagePairs[sFarIndex].fileNameFar = file.name;
            imagePairs[sFarIndex].imageFar = img;
            [imagePairs[sFarIndex].lineFar, imagePairs[sFarIndex].yFar] = extractBestImageLine(img);
            imagePairs[sFarIndex].lineCleanFar = subtractBackground(imagePairs[sFarIndex].lineFar)
        }
        displayFiles();
    });

  });

  // allow re-selecting same files again
  fileDataInput.value = "";
});


// ---------- M2 calculation ----------
/**
 * Compute 1D second-moment beam radius (ISO 11146)
 * @param {Float32Array|Float64Array} I  intensity line
 * @param {number} dx  pixel size [meters]
 * @returns {number} beam radius w [meters]
 */
function secondMomentRadius(I, dx) {
    let sumI = 0;
    let sumX = 0;
    let sumX2 = 0;

    for (let i = 0; i < I.length; i++) {
        const x = i * dx;
        const v = I[i];
        sumI += v;
        sumX += v * x;
        sumX2 += v * x * x;
    }

    const xbar = sumX / sumI;
    const variance = sumX2 / sumI - xbar * xbar;

    // ISO definition: w = sqrt(2 * variance)
    return [Math.sqrt(2 * variance), xbar, sumI];
}

/**
 * Compute M² from two beam profiles
 *
 * @param {TypedArray} I1  near-field intensity line
 * @param {TypedArray} I2  far-field intensity line
 * @param {number} dx      pixel size [meters]
 * @param {number} dz      propagation distance [meters]
 * @param {number} lambda  wavelength [meters]
 * @returns {number} M²
 */
function computeMSquared(I1, I2, dx, dz, lambda, aFactor) {
    const stats1 = secondMomentRadius(I1, dx);
    const stats2 = secondMomentRadius(I2, dx);

    const w1 = stats1[0];
    const w2 = stats2[0];

    console.log({
        w1_um: w1 * 1e6,
        w2_um: w2 * 1e6,
        dz_mm: dz * 1e3,
        lambda_nm: lambda * 1e9
    });
    if (w2 <= w1) {
        return [- 1.0, stats1, stats2];
    }

    const A = aFactor;
    const B = dz;
    if (w2 < Math.abs(A) * w1) {
         return [-1, stats1, stats2];
     }
    // calculation for 4f vs 1f3f
    const M2 = Math.PI * w1 / (lambda * dz) * Math.sqrt(w2 * w2 - A * A * w1 * w1);

    // calculation for 4f vs 1f 1f
    //const M2 = Math.sqrt(Math.PI * w1 * w2 / (lambda * dz));

    //const term = Math.sqrt(w1 * w1 * (w2 * w2 - w1 * w1));
    //const M2 = Math.PI * term / (lambda * dz)
    return [M2, stats1, stats2];
}

function calculateM2(pair) {

  pair.lineCleanNear = subtractBackground(pair.lineNear);
  pair.lineCleanFar = subtractBackground(pair.lineFar);
  pair.nearGaussianMatch = matchGaussian(pair.lineNear);
  const dxMicrons = parseFloat(document.getElementById("dxMicrons").value.trim());
  const dzCm = parseFloat(document.getElementById("dzCm").value.trim());
  const aFactor = parseFloat(document.getElementById("aFactor").value.trim());
  const lamdaNm = parseFloat(document.getElementById("lamdaNm").value.trim());
  
  const rc = computeMSquared(pair.lineCleanNear, pair.lineCleanFar, dxMicrons * 1E-06, dzCm * 0.01, lamdaNm * 1E-09, aFactor);
  
  pair.M2 = rc[0];
  for (let i = 0; i < 3; i++) {
    pair.statNear[i] = rc[1][i];
    pair.statFar[i] = rc[2][i];
  }
}

document.getElementById("calcBtn").addEventListener("click", () => {

  if (!imagePairs.length) return;
  imagePairs.forEach(p => {
    calculateM2(p);
  });

  displayFiles();
  drawSingle(0);
  drawM2();
});

function displayFileData(i, s) {
  return `<tr onclick="drawSingle(${i});" style="cursor: pointer;"><td>${s.fileLabel}</td>` + 
    `<td>${s.gridsDistance}</td><td style="font-size: 10px; font-family: monospace;">${s.fileNameNear}</br>${s.fileNameFar}</td><td>${s.M2}</td>` + 
    `<td>${(s.statNear[0]* 1000.0).toFixed(3)}</br>${(s.statFar[0]* 1000.0).toFixed(3)}</td></tr>`
}
function displayFiles() {
  document.getElementById("tableFiles").innerHTML = 
    `<table><tr><td>Label</td><td>Distance</td><td>Files</td><td>M-Square</td><td>Widths (mm)</td></tr>${imagePairs.map((s, i) => displayFileData(i, s)).join('')}</table>`;
}
const marginPlot = 40;
// ---------- Plotting ----------
function findNearestPoint(screenPts, mx, my, radius) {
  let best = null;
  let bestP =- 1
  let bestDist2 = radius * radius;

  for (const p in screenPts) {
    const dx = screenPts[p].x - mx;
    const dy = screenPts[p].y - my;
    const d2 = dx * dx + dy * dy;
    if (d2 < bestDist2) {
      bestDist2 = d2;
      best = screenPts[p];
      bestP = p;
    }
  }
  return [best, bestP];
}

function drawMarker(canvas, ctx, p) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
  ctx.fill();
}

function drawTooltip(canvas, ctx, p, mx, my) {
  const text = `D = ${p.ox.toPrecision(6)} B = ${p.oy.toPrecision(4)}`;

  ctx.font = "12px Arial";
  const pad = 4;
  const w = ctx.measureText(text).width + 2 * pad;
  const h = 28;

  const tx = mx + 10;
  const ty = my - h - 10;

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.fillRect(tx, ty, w, h);

  ctx.strokeStyle = "#333";
  ctx.strokeRect(tx, ty, w, h);

  ctx.fillStyle = "#000";
  ctx.fillText(text, tx + pad, ty + 14);
}

canvasM2.addEventListener("mousemove", e => {
  if (!M2ScreeenPts.length) return;
  const rect = canvasM2.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const [hit, i] = findNearestPoint(M2ScreeenPts, mx, my, 25);
  drawM2();
  if (hit) {
    drawMarker(canvasM2, ctxM2, hit);
    drawTooltip(canvasM2, ctxM2, hit, mx, my);
  }
});
canvasM2.addEventListener("click", e => {
  if (!M2ScreeenPts.length) return;
  const rect = canvasM2.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const [hit, i] = findNearestPoint(M2ScreeenPts, mx, my, 25);
  if (hit) {
    calculateM2(imagePairs[i]);

    drawSingle(i); // Draw first spectrum by default
  } 
});

function scalesForPlots(canvas, margin, xData, yData) {
  const xmin = Math.min(...xData);
  const xmax = Math.max(...xData);
  const ymin = Math.min(...yData);
  const ymax = Math.max(...yData);

  const X = x => (x - xmin) / (xmax - xmin) * (canvas.width - 2 * margin) + margin;
  const Y = y => (canvas.height - 2 * margin) * (1 - (y - ymin) / (ymax - ymin)) + margin;

  return [X, Y];
}
function drawM2() {
  ctxM2.clearRect(0, 0, canvasM2.width, canvasM2.height);
  plotGrid(canvasM2, ctxM2, imagePairs.map(s => s.gridsDistance), imagePairs.map(s => s.M2), "lightgray");
  plotCurve(canvasM2, ctxM2, imagePairs.map(s => s.gridsDistance), imagePairs.map(s => s.M2), "red", null, null, M2ScreeenPts);
}

function drawSingle(i) {
  drawLines(i);
  let canvas = document.getElementById("imageNear");
  canvas.width = imagePairs[i].imageNear.width;
  canvas.height = imagePairs[i].imageNear.height;
  let ctx = canvas.getContext("2d");
  ctx.putImageData(imagePairs[i].imageNear,0,0);
  ctx.strokeStyle = "red";
  ctx.beginPath();
  ctx.moveTo(0, imagePairs[i].yNear);
  ctx.lineTo(canvas.width, imagePairs[i].yNear);
  ctx.stroke();
  canvas = document.getElementById("imageFar");
  canvas.width = imagePairs[i].imageFar.width;
  canvas.height = imagePairs[i].imageFar.height;
  ctx = canvas.getContext("2d");
  ctx.putImageData(imagePairs[i].imageFar,0,0);
  ctx.strokeStyle = "blue";
  ctx.beginPath();
  ctx.moveTo(0, imagePairs[i].yFar);
  ctx.lineTo(canvas.width, imagePairs[i].yFar);
  ctx.stroke();

  document.getElementById("m2FileName").value = imagePairs[i].fileLabel;
  document.getElementById("m2Output").value = imagePairs[i].M2.toFixed(3);

}

function logNorm(x) {
  const f = 0.5 / Math.max(...x);;
  return x.map(v => - Math.sqrt(- Math.log(v *f + 0.0000001)) );
  //return x.map(v => Math.log(v *f + 0.0000001)) ;
}
function drawLines(i) {
  ctxLines.clearRect(0, 0, canvasLines.width, canvasLines.height);
  ctxLogLines.clearRect(0, 0, canvasLogLines.width, canvasLogLines.height);
  const pair = imagePairs[i];
  if (!pair.lineNear.length || !pair.lineFar.length) return;

  const xVec = pair.lineNear.map((v, i) => i);

  const loglineNear = logNorm(pair.lineNear);
  const loglineFar = logNorm(pair.lineFar);
  const [X, Y] = scalesForPlots(canvasLines, marginPlot, xVec, pair.lineNear);
  const [logX, logY] = scalesForPlots(canvasLogLines, marginPlot, xVec, loglineNear);

  plotCurve(canvasLines, ctxLines, xVec, pair.lineNear, "#ffaaaa", X, Y);
  plotCurve(canvasLines, ctxLines, xVec, pair.lineFar, "#aaaaff", X, Y);
  plotCurve(canvasLines, ctxLines, xVec, pair.lineCleanNear, "red", X, Y);
  if (pair.nearGaussianMatch) {
    plotCurve(canvasLines, ctxLines, xVec, pair.nearGaussianMatch.fit, "green", X, Y);
  }
  plotCurve(canvasLines, ctxLines, xVec, pair.lineCleanFar, "blue", X, Y);
  plotGrid(canvasLogLines, ctxLogLines, xVec, loglineNear, "lightgray");
  plotCurve(canvasLogLines, ctxLogLines, xVec, loglineNear, "red", logX, logY);
  plotCurve(canvasLogLines, ctxLogLines, xVec, loglineFar, "blue", logX, logY);

  const dxMicrons = parseFloat(document.getElementById("dxMicrons").value.trim());
  const dx = dxMicrons * 1E-06;

  if (pair.statNear.length >= 3) {
      ctxLines.strokeStyle = "red";
      ctxLines.beginPath();
      let sx = Math.round((pair.statNear[1] - 0.5 * pair.statNear[0]) / dx);
      let ex = Math.round((pair.statNear[1] + 0.5 * pair.statNear[0]) / dx);
      ctxLines.moveTo(X(sx), canvasLines.height / 2);
      ctxLines.lineTo(X(ex), canvasLines.height / 2);
      ctxLines.stroke();
  }
  if (pair.statFar.length >= 3) {
      ctxLines.strokeStyle = "blue";
      ctxLines.beginPath();
      let sx = Math.round((pair.statFar[1] - 0.5 * pair.statFar[0]) / dx);
      let ex = Math.round((pair.statFar[1] + 0.5 * pair.statFar[0]) / dx);
      ctxLines.moveTo(X(sx), canvasLines.height / 2 - 10);
      ctxLines.lineTo(X(ex), canvasLines.height / 2 - 10);
      ctxLines.stroke();
  }
}


function plotCurve(canvas, ctx, x, y, color, X = null, Y = null, screenPts = null) {
  if (X === null || Y === null) {
    [X, Y] = scalesForPlots(canvas, marginPlot, x, y);
  }
  if (screenPts) screenPts.length = 0;

  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i < x.length; i++) {
    const px = X(x[i]);
    const py = Y(y[i]);
    if (screenPts) screenPts.push({x: px, y: py, i, ox:x[i], oy:y[i]});
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.stroke();
}
function plotGrid(canvas, ctx, x, y, color) {
  const nGrid = 10;
  const mxx = Math.max(...x);
  const mnx = Math.min(...x);
  const mxy = Math.max(...y);
  const mny = Math.min(...y);
  const xGridStep = (mxx - mnx) / nGrid;
  const yGridStep = (mxy - mny) / nGrid;
  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.moveTo(px, marginPlot);
    ctx.lineTo(px, canvas.height - marginPlot);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.moveTo(marginPlot, py);
    ctx.lineTo(canvas.width - marginPlot, py);
  }
  ctx.stroke();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.fillText(gx.toFixed(2), px - 10, canvas.height - marginPlot + 15);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.fillText(gy.toFixed(3), marginPlot - 35, py + 5); 
  }
}

function drawCircle(canvas, ctx, x, y) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2 * Math.PI);
  ctx.fill();
}

/**
 * Robust background subtraction for 1D beam profile
 *
 * @param {Float32Array|Float64Array} I
 * @param {number} centralFraction  fraction of profile width to ignore (0.3 is typical)
 * @returns {{signal: Float32Array, background: number}}
 */
function subtractBackground(I, centralFraction = 0.3) {
    const N = I.length;

    // --- rough centroid (no bg removal yet)
    let sumI = 0, sumX = 0;
    for (let i = 0; i < N; i++) {
        sumI += I[i];
        sumX += I[i] * i;
    }
    const xc = sumX / sumI;

    // --- define exclusion window
    const halfWidth = Math.floor(N * centralFraction / 2);
    const iMin = Math.max(0, Math.floor(xc - halfWidth));
    const iMax = Math.min(N, Math.floor(xc + halfWidth));

    // --- collect background samples
    const bgSamples = [];
    for (let i = 0; i < N; i++) {
        if (i < iMin || i > iMax) {
            bgSamples.push(I[i]);
        }
    }

    // --- robust estimator: median
    bgSamples.sort((a, b) => a - b);
    const mid = Math.floor(bgSamples.length / 2);
    const background =
        bgSamples.length % 2
            ? bgSamples[mid]
            : 0.5 * (bgSamples[mid - 1] + bgSamples[mid]);

    const subFactor = parseFloat(document.getElementById("subFactor").value.trim());
    // --- subtract and clamp
    const out = new Float32Array(N);
    for (let i = 0; i < N; i++) {
        out[i] = Math.max(I[i] - subFactor * background, 0);
    }

    return out;
    //return { signal: out, background };
}
function matchGaussian(y, options = {}) {
    const N = y.length;

    // ---------- parameters
    const sigmaMin = options.sigmaMin ?? 2;
    const sigmaMax = options.sigmaMax ?? 80;
    const sigmaSteps = options.sigmaSteps ?? 60;

    // ---------- background removal
    const sorted = [...y].sort((a, b) => a - b);
    const B = sorted[Math.floor(0.1 * N)];
    const s = y.map(v => Math.max(0, v - B));

    // ---------- peak estimate
    let peak = 0;
    for (let i = 1; i < N; i++) {
        if (s[i] > s[peak]) peak = i;
    }

    let best = {
        score: -Infinity,
        x0: peak,
        sigma: sigmaMin
    };

    // ---------- precompute x
    const x = [...Array(N).keys()];

    // ---------- scan parameters
    for (let k = 0; k < sigmaSteps; k++) {
        const sigma =
            sigmaMin * Math.pow(sigmaMax / sigmaMin, k / (sigmaSteps - 1));

        const inv2s2 = 1 / (2 * sigma * sigma);

        for (let x0 = peak - 40; x0 <= peak + 40; x0++) {
            if (x0 < 0 || x0 >= N) continue;

            let dot = 0;
            let normG = 0;

            for (let i = 0; i < N; i++) {
                const g = Math.exp(-((i - x0) ** 2) * inv2s2);
                dot += s[i] * g;
                normG += g * g;
            }

            const score = dot / Math.sqrt(normG);

            if (score > best.score) {
                best = { score, x0, sigma };
            }
        }
    }

    // ---------- amplitude (least squares)
    let num = 0, den = 0;
    for (let i = 0; i < N; i++) {
        const g = Math.exp(-((i - best.x0) ** 2) / (2 * best.sigma ** 2));
        num += s[i] * g;
        den += g * g;
    }
    const A = num / den;

    // ---------- fitted curve
    const fit = x.map(i =>
        B + A * Math.exp(-((i - best.x0) ** 2) / (2 * best.sigma ** 2))
    );

    return {
        x0: best.x0,
        sigma: best.sigma,
        A,
        B,
        score: best.score,
        fit
    };
}

</script>

</body>
</html>
