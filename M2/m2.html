<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laser Beam M-Square Tool</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; }
  .controls { margin-top: 10px; }
  input[type="number"] { width: 60px; }
</style>

</head>
<body>
<script src="./UTIF.js"></script>
<script>
  console.log(UTIF); // should work
</script>

<h2>Laser Beam M-Square</h2>
<div style="display: flex; flex-direction: row; gap: 10px;">
<div>
<label>Camera pixel size (microns)<input type="number" id="dxMicrons" value="3.45" step="0.1"></label>
<label>Focal length (cm)<input type="number" id="dzCm" value="5" step="1"></label>
<label>Wave length (nm)<input type="number" id="lamdaNm" value="1064" step="0.1"></label>
<div>
<label>
  Load directory:
<input type="file" id="fileDirectoryInput" accept=".csv">
</label>
</div>

<label>
  Load images:
<input type="file" id="fileDataInput" accept=".tif,.png" multiple>
</label>
<div class="controls">
  <button id="calcBtn">Calc</button>
</div>


<canvas id="plotM2" width="900" height="400"></canvas>
<p>File: <input type="text" id="m2FileName" size="20" readonly></p>
<p>M2: <input type="text" id="m2Output" size="20" readonly></p>
<canvas id="plotLines" width="900" height="400"></canvas>
<div id="dataTable"></div>
</div>
<div id="tableFiles"></div>
</div>
<div style="display: flex; flex-direction: row; gap: 10px;">
<canvas id="imageNear" width="400" height="400"></canvas>
<canvas id="imageFar" width="400" height="400"></canvas>
</div>
<script>
const canvasM2 = document.getElementById("plotM2");
const ctxM2 = canvasM2.getContext("2d");
const M2ScreeenPts = [];
const canvasLines = document.getElementById("plotLines");
const ctxLines = canvasLines.getContext("2d");

class imagePairData {
  constructor(fileLabel, gridsDistance) {
    this.fileLabel = fileLabel;
    this.gridsDistance = gridsDistance;
    this.fileNameNear = "-";
    this.imageNear = null;
    this.yNear = -1;
    this.lineNear = [];
    this.lineCleanNear = [];
    this.statNear = [];
    this.fileNameFar = "-";
    this.imageFar = null;
    this.yFear = -1;
    this.lineFar = [];
    this.lineCleanFar = [];
    this.statFar = [];
    this.M2 = 0.0;
  }
}

let imagePairs = [];
let crossings = null;
let threshold = null;
const inputSelect = document.getElementById("inputSelect");

// ---------- CSV parsing ----------
document.getElementById("fileDirectoryInput").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    parseDirectoryCSV(reader.result);
    fileDirectoryInput.value = "";
  };
  reader.readAsText(file);
});

function parseDirectoryCSV(text) {
  imagePairs = [];

  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const cols = line.split(/[,;\t]/);
    if (cols.length < 2) continue;
    const distance = parseFloat(cols[1].trim());
    const fileLabel = cols[0].trim();
    if (!isNaN(distance) && fileLabel) {
      imagePairs.push(new imagePairData(fileLabel, distance));
    }
  }
  imagePairs.sort((a, b) => a.gridsDistance - b.gridsDistance);

  displayFiles();

  console.log("Parsed directory CSV:", imagePairs);
}

// ---------- image file processing ----------
function matchLabel(t, l, name) {
    return name.toLowerCase().includes(t) && name.includes(l);
}

function readImageData(file) {
    if (file.name.includes(".tif")) {
      return readTiffData(file);
    }
    return new Promise((resolve, reject) => {
        const img = new Image();

        img.src = URL.createObjectURL(file);
        
        img.onload = () => {
            const canvas = new OffscreenCanvas(img.width, img.height);
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            console.log("Original image size:", imageData.width, imageData.height);
            resolve(imageData);
        };
        img.onerror = reject;
    });
}

async function readTiffData(file) {
  const buffer = await file.arrayBuffer();

  const ifds = UTIF.decode(buffer);
  UTIF.decodeImage(buffer, ifds[0]);

  const rgba = UTIF.toRGBA8(ifds[0]); // Uint8Array [R,G,B,A,...]
  const w = ifds[0].width;
  const h = ifds[0].height;

  const canvas = new OffscreenCanvas(w, h);
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, w, h);
  for (let i = 0; i < rgba.length; i += 4) {
    imageData.data[i] = rgba[i];
    imageData.data[i + 1] = rgba[i + 1];
    imageData.data[i + 2] = rgba[i + 2];
    imageData.data[i + 3] = 255;
  }


  return imageData;
}

function extractBestImageLine(img) {
    let line = [];
    let maxIntens = - 1;
    let bestY = - 1;
    for (let y = 0; y < img.height; y++) {
        let lineIntens = 0;
        for (let x = 0; x < img.width; x++) {
            let w = (img.width - x) * (img.width - x);
            const srcIndex = 4 * (y * img.width + x);
            lineIntens += img.data[srcIndex] * w;
        }
        if (maxIntens < lineIntens) {
            maxIntens = lineIntens;
            bestY = y;
        }
    }
    if (bestY >= 0) {
        for (let x = 0; x < img.width; x++) {
            const srcIndex = 4 * (bestY * img.width + x);
            line.push(img.data[srcIndex]);
        }
       
    }
    return [line, bestY];
}

document.getElementById("fileDataInput").addEventListener("change", () => {
  const files = Array.from(fileDataInput.files);
  if (!files.length) return;

  displayFiles();
  
  files.forEach(file => {

    // ✅ filename condition
    const sNearIndex = imagePairs.findIndex(s => matchLabel("near", s.fileLabel, file.name));
    const sFarIndex = imagePairs.findIndex(s => matchLabel("far", s.fileLabel, file.name));
    if (sNearIndex < 0 && sFarIndex < 0) {
      return;   // skip this file
    }

    readImageData(file).then(img => {
        if (sNearIndex >= 0) {
            imagePairs[sNearIndex].fileNameNear = file.name;
            imagePairs[sNearIndex].imageNear = img;
            [imagePairs[sNearIndex].lineNear, imagePairs[sNearIndex].yNear] = extractBestImageLine(img)
            imagePairs[sNearIndex].lineCleanNear = subtractBackground(imagePairs[sNearIndex].lineNear)
            
        } else if (sFarIndex >= 0) {
            imagePairs[sFarIndex].fileNameFar = file.name;
            imagePairs[sFarIndex].imageFar = img;
            [imagePairs[sFarIndex].lineFar, imagePairs[sFarIndex].yFar] = extractBestImageLine(img);
            imagePairs[sFarIndex].lineCleanFar = subtractBackground(imagePairs[sFarIndex].lineFar)
        }
        displayFiles();
    });

  });

  // allow re-selecting same files again
  fileDataInput.value = "";
});


// ---------- M2 calculation ----------
/**
 * Compute 1D second-moment beam radius (ISO 11146)
 * @param {Float32Array|Float64Array} I  intensity line
 * @param {number} dx  pixel size [meters]
 * @returns {number} beam radius w [meters]
 */
function secondMomentRadius(I, dx) {
    let sumI = 0;
    let sumX = 0;
    let sumX2 = 0;

    for (let i = 0; i < I.length; i++) {
        const x = i * dx;
        const v = I[i];
        sumI += v;
        sumX += v * x;
        sumX2 += v * x * x;
    }

    const xbar = sumX / sumI;
    const variance = sumX2 / sumI - xbar * xbar;

    // ISO definition: w = sqrt(2 * variance)
    return [Math.sqrt(2 * variance), xbar, sumI];
}

/**
 * Compute M² from two beam profiles
 *
 * @param {TypedArray} I1  near-field intensity line
 * @param {TypedArray} I2  far-field intensity line
 * @param {number} dx      pixel size [meters]
 * @param {number} dz      propagation distance [meters]
 * @param {number} lambda  wavelength [meters]
 * @returns {number} M²
 */
function computeMSquared(I1, I2, dx, dz, lambda) {
    const stats1 = secondMomentRadius(I1, dx);
    const stats2 = secondMomentRadius(I2, dx);

    const w1 = stats1[0];
    const w2 = stats2[0];

    console.log({
        w1_um: w1 * 1e6,
        w2_um: w2 * 1e6,
        dz_mm: dz * 1e3,
        lambda_nm: lambda * 1e9
    });
    if (w2 <= w1) {
        return [- 1.0, stats1, stats2];
    }

    const A = -2;
    const B = dz;
    if (w2 < Math.abs(A) * w1) {
        return [-1, stats1, stats2];
    }
    const M2 = Math.PI * w1 / (lambda * dz) * Math.sqrt(w2 * w2 - A * A * w1 * w1);

    //const term = Math.sqrt(w1 * w1 * (w2 * w2 - w1 * w1));
    //const M2 = Math.PI * term / (lambda * dz)
    return [M2, stats1, stats2];
}

function calculateM2(pair) {

  const dxMicrons = parseFloat(document.getElementById("dxMicrons").value.trim());
  const dzCm = parseFloat(document.getElementById("dzCm").value.trim());
  const lamdaNm = parseFloat(document.getElementById("lamdaNm").value.trim());
  
  const rc = computeMSquared(pair.lineCleanNear, pair.lineCleanFar, dxMicrons * 1E-06, dzCm * 0.01, lamdaNm * 1E-09);
  
  pair.M2 = rc[0];
  for (let i = 0; i < 3; i++) {
    pair.statNear[i] = rc[1][i];
    pair.statFar[i] = rc[2][i];
  }
}

document.getElementById("calcBtn").addEventListener("click", () => {

  if (!imagePairs.length) return;
  imagePairs.forEach(p => {
    calculateM2(p);
  });

  displayFiles();
  drawSingle(0);
  drawM2();
});

function displayFileData(i, s) {
  return `<tr onclick="drawSingle(${i});" style="cursor: pointer;"><td>${s.fileLabel}</td>` + 
    `<td>${s.gridsDistance}</td><td style="font-size: 10px; font-family: monospace;">${s.fileNameNear}</br>${s.fileNameFar}</td><td>${s.M2}</td>` + 
    `<td>${(s.statNear[0]* 1000.0).toFixed(3)}</br>${(s.statFar[0]* 1000.0).toFixed(3)}</td></tr>`
}
function displayFiles() {
  document.getElementById("tableFiles").innerHTML = 
    `<table><tr><td>Label</td><td>Distance</td><td>Files</td><td>M-Square</td><td>Widths (mm)</td></tr>${imagePairs.map((s, i) => displayFileData(i, s)).join('')}</table>`;
}
const marginPlot = 40;
// ---------- Plotting ----------
function findNearestPoint(screenPts, mx, my, radius) {
  let best = null;
  let bestP =- 1
  let bestDist2 = radius * radius;

  for (const p in screenPts) {
    const dx = screenPts[p].x - mx;
    const dy = screenPts[p].y - my;
    const d2 = dx * dx + dy * dy;
    if (d2 < bestDist2) {
      bestDist2 = d2;
      best = screenPts[p];
      bestP = p;
    }
  }
  return [best, bestP];
}

function drawMarker(canvas, ctx, p) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
  ctx.fill();
}

function drawTooltip(canvas, ctx, p, mx, my) {
  const text = `D = ${p.ox.toPrecision(6)} B = ${p.oy.toPrecision(4)}`;

  ctx.font = "12px Arial";
  const pad = 4;
  const w = ctx.measureText(text).width + 2 * pad;
  const h = 28;

  const tx = mx + 10;
  const ty = my - h - 10;

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.fillRect(tx, ty, w, h);

  ctx.strokeStyle = "#333";
  ctx.strokeRect(tx, ty, w, h);

  ctx.fillStyle = "#000";
  ctx.fillText(text, tx + pad, ty + 14);
}

canvasM2.addEventListener("mousemove", e => {
  if (!M2ScreeenPts.length) return;
  const rect = canvasM2.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const [hit, i] = findNearestPoint(M2ScreeenPts, mx, my, 25);
  drawM2();
  if (hit) {
    drawMarker(canvasM2, ctxM2, hit);
    drawTooltip(canvasM2, ctxM2, hit, mx, my);
  }
});
canvasM2.addEventListener("click", e => {
  if (!M2ScreeenPts.length) return;
  const rect = canvasM2.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const [hit, i] = findNearestPoint(M2ScreeenPts, mx, my, 25);
  if (hit) {
    calculateM2(imagePairs[i]);

    drawSingle(i); // Draw first spectrum by default
  } 
});

function scalesForPlots(canvas, margin, xData, yData) {
  const xmin = Math.min(...xData);
  const xmax = Math.max(...xData);
  const ymin = Math.min(...yData);
  const ymax = Math.max(...yData);

  const X = x => (x - xmin) / (xmax - xmin) * (canvas.width - 2 * margin) + margin;
  const Y = y => (canvas.height - 2 * margin) * (1 - (y - ymin) / (ymax - ymin)) + margin;

  return [X, Y];
}
function drawM2() {
  ctxM2.clearRect(0, 0, canvasM2.width, canvasM2.height);
  plotGrid(canvasM2, ctxM2, imagePairs.map(s => s.gridsDistance), imagePairs.map(s => s.M2), "lightgray");
  plotCurve(canvasM2, ctxM2, imagePairs.map(s => s.gridsDistance), imagePairs.map(s => s.M2), "red", null, null, M2ScreeenPts);
}

function drawSingle(i) {
  drawLines(i);
  let canvas = document.getElementById("imageNear");
  canvas.width = imagePairs[i].imageNear.width;
  canvas.height = imagePairs[i].imageNear.height;
  let ctx = canvas.getContext("2d");
  ctx.putImageData(imagePairs[i].imageNear,0,0);
  ctx.strokeStyle = "red";
  ctx.beginPath();
  ctx.moveTo(0, imagePairs[i].yNear);
  ctx.lineTo(canvas.width, imagePairs[i].yNear);
  ctx.stroke();
  canvas = document.getElementById("imageFar");
  canvas.width = imagePairs[i].imageFar.width;
  canvas.height = imagePairs[i].imageFar.height;
  ctx = canvas.getContext("2d");
  ctx.putImageData(imagePairs[i].imageFar,0,0);
  ctx.strokeStyle = "blue";
  ctx.beginPath();
  ctx.moveTo(0, imagePairs[i].yFar);
  ctx.lineTo(canvas.width, imagePairs[i].yFar);
  ctx.stroke();

  document.getElementById("m2FileName").value = imagePairs[i].fileLabel;
  document.getElementById("m2Output").value = imagePairs[i].M2.toFixed(3);

}

function drawLines(i) {
  ctxLines.clearRect(0, 0, canvasLines.width, canvasLines.height);
  const pair = imagePairs[i];
  if (!pair.lineNear.length || !pair.lineFar.length) return;

  const xVec = pair.lineNear.map((v, i) => i);

  const [X, Y] = scalesForPlots(canvasLines, marginPlot, xVec, pair.lineNear);

  plotCurve(canvasLines, ctxLines, xVec, pair.lineNear, "#ffaaaa", X, Y);
  plotCurve(canvasLines, ctxLines, xVec, pair.lineFar, "#aaaaff", X, Y);
  plotCurve(canvasLines, ctxLines, xVec, pair.lineCleanNear, "red", X, Y);
  plotCurve(canvasLines, ctxLines, xVec, pair.lineCleanFar, "blue", X, Y);

  const dxMicrons = parseFloat(document.getElementById("dxMicrons").value.trim());
  const dx = dxMicrons * 1E-06;

  if (pair.statNear.length >= 3) {
      ctxLines.strokeStyle = "red";
      ctxLines.beginPath();
      let sx = Math.round((pair.statNear[1] - 0.5 * pair.statNear[0]) / dx);
      let ex = Math.round((pair.statNear[1] + 0.5 * pair.statNear[0]) / dx);
      ctxLines.moveTo(X(sx), canvasLines.height / 2);
      ctxLines.lineTo(X(ex), canvasLines.height / 2);
      ctxLines.stroke();
  }
  if (pair.statFar.length >= 3) {
      ctxLines.strokeStyle = "blue";
      ctxLines.beginPath();
      let sx = Math.round((pair.statFar[1] - 0.5 * pair.statFar[0]) / dx);
      let ex = Math.round((pair.statFar[1] + 0.5 * pair.statFar[0]) / dx);
      ctxLines.moveTo(X(sx), canvasLines.height / 2 - 10);
      ctxLines.lineTo(X(ex), canvasLines.height / 2 - 10);
      ctxLines.stroke();
  }
}


function plotCurve(canvas, ctx, x, y, color, X = null, Y = null, screenPts = null) {
  if (X === null || Y === null) {
    [X, Y] = scalesForPlots(canvas, marginPlot, x, y);
  }
  if (screenPts) screenPts.length = 0;

  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i < x.length; i++) {
    const px = X(x[i]);
    const py = Y(y[i]);
    if (screenPts) screenPts.push({x: px, y: py, i, ox:x[i], oy:y[i]});
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.stroke();
}
function plotGrid(canvas, ctx, x, y, color) {
  const nGrid = 10;
  const mxx = Math.max(...x);
  const mnx = Math.min(...x);
  const mxy = Math.max(...y);
  const mny = Math.min(...y);
  const xGridStep = (mxx - mnx) / nGrid;
  const yGridStep = (mxy - mny) / nGrid;
  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.moveTo(px, marginPlot);
    ctx.lineTo(px, canvas.height - marginPlot);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.moveTo(marginPlot, py);
    ctx.lineTo(canvas.width - marginPlot, py);
  }
  ctx.stroke();
  for (let i = 0; i <= nGrid; i++) {
    const gx = mnx + i * xGridStep;
    const px = (gx - mnx) / (mxx - mnx) * (canvas.width - 2 * marginPlot) + marginPlot;
    ctx.fillText(gx.toFixed(2), px - 10, canvas.height - marginPlot + 15);
  }
  for (let i = 0; i <= nGrid; i++) {
    const gy = mny + i * yGridStep;
    const py = (canvas.height - 2 * marginPlot) * (1 - (gy - mny) / (mxy - mny)) + marginPlot;
    ctx.fillText(gy.toFixed(3), marginPlot - 35, py + 5); 
  }
}

function drawCircle(canvas, ctx, x, y) {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2 * Math.PI);
  ctx.fill();
}

/**
 * Robust background subtraction for 1D beam profile
 *
 * @param {Float32Array|Float64Array} I
 * @param {number} centralFraction  fraction of profile width to ignore (0.3 is typical)
 * @returns {{signal: Float32Array, background: number}}
 */
function subtractBackground(I, centralFraction = 0.3) {
    const N = I.length;

    // --- rough centroid (no bg removal yet)
    let sumI = 0, sumX = 0;
    for (let i = 0; i < N; i++) {
        sumI += I[i];
        sumX += I[i] * i;
    }
    const xc = sumX / sumI;

    // --- define exclusion window
    const halfWidth = Math.floor(N * centralFraction / 2);
    const iMin = Math.max(0, Math.floor(xc - halfWidth));
    const iMax = Math.min(N, Math.floor(xc + halfWidth));

    // --- collect background samples
    const bgSamples = [];
    for (let i = 0; i < N; i++) {
        if (i < iMin || i > iMax) {
            bgSamples.push(I[i]);
        }
    }

    // --- robust estimator: median
    bgSamples.sort((a, b) => a - b);
    const mid = Math.floor(bgSamples.length / 2);
    const background =
        bgSamples.length % 2
            ? bgSamples[mid]
            : 0.5 * (bgSamples[mid - 1] + bgSamples[mid]);

    // --- subtract and clamp
    const out = new Float32Array(N);
    for (let i = 0; i < N; i++) {
        out[i] = Math.max(I[i] - background, 0);
    }

    return out;
    //return { signal: out, background };
}

</script>

</body>
</html>
