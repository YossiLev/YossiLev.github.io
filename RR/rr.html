<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Thin Layer Optics – Transfer Matrix</title>

<style>
:root{
  --bg:#f2f4f8; --panel:#fff; --border:#d0d5dd;
  --accent:#3b82f6; --text:#1f2937;
}
body{
  margin:0; font-family:system-ui,sans-serif;
  background:var(--bg); color:var(--text);
}
#topbar{
  display:flex; gap:12px; padding:10px;
  background:#111827; color:white; align-items:center;
}
#topbar input,#topbar select,#topbar button{
  padding:6px 10px; border-radius:6px; border:none;
}
#topbar button{background:var(--accent); color:white; cursor:pointer;}
#container{display:flex; height:calc(100vh - 52px);}
#controls{
  width:330px; background:var(--panel);
  border-right:1px solid var(--border);
  padding:12px; overflow:auto;
}
.layer{
  border:1px solid var(--border);
  border-radius:10px; padding:10px; margin-bottom:10px;
  background:#fafafa;
}
.layerHeader{display:flex; justify-content:space-between; font-weight:600;}
.layerGrid{
  display:grid; grid-template-columns:1fr 1fr; gap:6px; font-size:13px;
}
.layerGrid input{width:100%; padding:4px;}
canvas{flex:1; background:white;}

#helpOverlay{
  position:fixed; inset:0; background:rgba(0,0,0,0.6);
  display:none; z-index:10;
}
.helpFrame{
  position:absolute; background:white; padding:14px;
  border-radius:10px; width:260px;
}
</style>
</head>

<body>

<div id="topbar">
  λ₀:
  <input type="number" id="lambdaInput" value="1" step="0.1">
  Preset:
  <select id="presetSelect"></select>
  <button id="runBtn">Run</button>
  <button id="helpBtn">Help</button>
</div>

<div id="container">
  <div id="controls">
    <h3>Layers</h3>
    <div id="layers"></div>
    <button onclick="addLayer()">Add layer</button>
  </div>
  <canvas id="canvas"></canvas>
</div>

<div id="helpOverlay" onclick="this.style.display='none'">
  <div class="helpFrame" style="top:20%; left:10%;">Incident / reflected wave</div>
  <div class="helpFrame" style="top:45%; left:40%;">Internal standing waves</div>
  <div class="helpFrame" style="top:70%; left:15%;">Energy flux arrows</div>
</div>

<script>
/* =====================================================
   COMPLEX ARITHMETIC
   ===================================================== */
function c(re,im=0){return{re,im};}
function add(a,b){return c(a.re+b.re,a.im+b.im);}
function sub(a,b){return c(a.re-b.re,a.im-b.im);}
function mul(a,b){
  return c(a.re*b.re-a.im*b.im,a.re*b.im+a.im*b.re);
}
function div(a,b){
  const d=b.re*b.re+b.im*b.im;
  return c((a.re*b.re+a.im*b.im)/d,(a.im*b.re-a.re*b.im)/d);
}
function expi(x){return c(Math.cos(x),Math.sin(x));}
function expc(z){
  const e=Math.exp(z.re);
  return c(e*Math.cos(z.im),e*Math.sin(z.im));
}
function abs2(z){return z.re*z.re+z.im*z.im;}

/* =====================================================
   TRANSFER MATRIX
   ===================================================== */
function interfaceM(n1,n2){
  const r = div(sub(n2,n1), add(n2,n1));
  const t = div(c(2*n1.re,2*n1.im), add(n2,n1));
  return [
    [div(c(1),t), div(r,t)],
    [div(r,t), div(c(1),t)]
  ];
}

function propagationM(k,n,d){
  const phi = mul(c(0,k*d), n); // i*k*n*d
  return [
    [expc(phi), c(0)],
    [c(0), expc(c(-phi.re,-phi.im))]
  ];
}

function matMul(A,B){
  return [
    [
      add(mul(A[0][0],B[0][0]),mul(A[0][1],B[1][0])),
      add(mul(A[0][0],B[0][1]),mul(A[0][1],B[1][1]))
    ],
    [
      add(mul(A[1][0],B[0][0]),mul(A[1][1],B[1][0])),
      add(mul(A[1][0],B[0][1]),mul(A[1][1],B[1][1]))
    ]
  ];
}

function solveStack(k,layers){
  let M=[[c(1),c(0)],[c(0),c(1)]];
  let nPrev=c(1);

  for(const L of layers){
    const n=c(L.n,L.k);
    M=matMul(interfaceM(nPrev,n),M);
    M=matMul(propagationM(k,n,L.d),M);
    nPrev=n;
  }
  M=matMul(interfaceM(nPrev,c(1)),M);

  const Aplus=c(1);
  const Aminus=div(mul(c(-1),M[1][0]),M[1][1]);
  return {Aplus,Aminus};
}

/* =====================================================
   FIELD EVALUATION
   ===================================================== */
function fieldAt(z,k,amps){
  let z0=0;
  let Ap=amps.Aplus, Am=amps.Aminus;

  for(const L of sim.layers){
    if(z<L.z){
      return add(mul(Ap,expi(k*z)),mul(Am,expi(-k*z)));
    }
    const dz=L.z-z0;
    Ap=mul(Ap,expi(k*dz));
    Am=mul(Am,expi(-k*dz));

    if(z<=L.z+L.d){
      const n=c(L.n,L.k);
      const zz=z-L.z;
      return add(
        mul(Ap,expc(mul(c(0,k*zz),n))),
        mul(Am,expc(mul(c(0,-k*zz),n)))
      );
    }
    const n=c(L.n,L.k);
    Ap=mul(Ap,expc(mul(c(0,k*L.d),n)));
    Am=mul(Am,expc(mul(c(0,-k*L.d),n)));
    z0=L.z+L.d;
  }
  return add(
    mul(Ap,expi(k*(z-z0))),
    mul(Am,expi(-k*(z-z0)))
  );
}

/* =====================================================
   ENERGY FLUX (Poynting proxy)
   ===================================================== */
function fluxAt(z,k,amps){
  const E=fieldAt(z,k,amps);
  return abs2(E);
}

/* =====================================================
   SIM STATE + PRESETS
   ===================================================== */
const sim={
  lambda:1, phase:0, running:false, layers:[]
};
const startWall = {position: 0.0, n1: - 1, n2: 1};
const walls=[]; /* wall = {position, n1, n2} */
const startRay = {sWall: 0, direction: 1, amplitude: 1.0, intensity: 1.0, phase: 0, sTime: 0};
const rays=[]; /* ray = {sWall, direction (1 left to right, -1 right to left), amplitude, phase, sTime, d1, d2} */

const presets={
  "Free space":()=>[],
  "Partial reflection":()=>[{z:3,d:0.5,n:1.5,k:0}],
  "Fabry–Pérot":()=>[{z:3,d:0.2,n:2,k:0}, {z:4,d:0.2,n:2,k:0}],
  "Anti-reflection λ/4":()=>[{z:3,d:0.25,n:Math.sqrt(1.5),k:0}],
  "Absorbing layer":()=>[{z:3,d:0.8,n:1.5,k:0.4}]
};

function buildWalls() {
  walls.length=0;
  walls.push(startWall);
  let nPrev=1;
  sim.layers.forEach(L=>{
    walls.push({position:L.z, n1:nPrev, n2:L.n});
    nPrev=L.n;
    walls.push({position:L.z+L.d, n1:L.n, n2:1});
    nPrev=1;
  });
  walls.push({position: 10.0, n1: 1, n2: 1});
}

function buildRays() {
  rays.length=0;
  rays.push(startRay);
  let nextRayIndex = 0;
  while (nextRayIndex < rays.length) {
    const ray = rays[nextRayIndex];
    const nextWallIndex = ray.sWall + ray.direction;
    const lastN = ray.direction === 1 ? walls[ray.sWall].n2 : walls[ray.sWall].n1;
    if (nextWallIndex < 1 || nextWallIndex >= walls.length - 1) {
      nextRayIndex++;
      continue;
    }
    const wall = walls[nextWallIndex];
    const n1 = ray.direction === 1 ? wall.n1 : wall.n2;
    const n2 = ray.direction === 1 ? wall.n2 : wall.n1;
    const r = (n2 - n1) / (n2 + n1);
    const t = (2 * n1) / (n2 + n1);
    const reflectedAmplitude = ray.amplitude * r;
    const reflectedIntensity = reflectedAmplitude * reflectedAmplitude * n1;
    const transmittedAmplitude = ray.amplitude * t;
    const transmittedIntensity = transmittedAmplitude * transmittedAmplitude * n2;
    const phase = ray.phase + Math.abs(wall.position - walls[ray.sWall].position) / sim.lambda * 2.0 * Math.PI * lastN;
    const stime = ray.sTime + Math.abs(wall.position - walls[ray.sWall].position) * lastN;
    if (reflectedIntensity > 0.000001) {
      const addPhase = n2 > n1 ? Math.PI : 0;
      const multAmpliture = n2 > n1 ? -1 : 1;
      rays.push({
        sWall: nextWallIndex,
        direction: -ray.direction,
        amplitude: reflectedAmplitude * multAmpliture,
        intensity: reflectedIntensity,
        phase: phase + addPhase,
        sTime: ray.sTime
      });
    }
    if (transmittedIntensity > 0.000001) {
      rays.push({
        sWall: nextWallIndex,
        direction: ray.direction,
        amplitude: transmittedAmplitude,
        intensity: transmittedIntensity,
        phase: phase,
        sTime: ray.sTime
      });
    }
    nextRayIndex++;
  }
}

function buildTotalRays() {
  for (const wall of walls) {
    wall.amplitudeForwards = c(0, 0);
    wall.amplitudeBackwards = c(0, 0);
  }
  for (let ray of rays) {
    const wall = walls[ray.sWall];
    if (ray.direction === 1) {
      wall.amplitudeForwards = add(wall.amplitudeForwards, mul(c(ray.amplitude), expi(ray.phase)));
    } else {
      wall.amplitudeBackwards = add(wall.amplitudeBackwards, mul(c(ray.amplitude), expi(ray.phase)));
    }
  }
}


const presetSelect=document.getElementById("presetSelect");
Object.keys(presets).forEach(p=>{
  const o=document.createElement("option"); o.textContent=p;
  presetSelect.appendChild(o);
});
presetSelect.onchange=()=>{
  sim.layers=presets[presetSelect.value]();
  renderLayers();
};
presetSelect.value="Partial reflection";
presetSelect.onchange();

/* =====================================================
   UI
   ===================================================== */
function renderLayers(){
  const div=document.getElementById("layers");
  div.innerHTML="";
  sim.layers.forEach((L,i)=>{
    const d=document.createElement("div");
    d.className="layer";
    d.innerHTML=`
      <div class="layerHeader">Layer ${i+1}
        <button onclick="removeLayer(${i})">✕</button>
      </div>
      <div class="layerGrid">
        z <input value="${L.z}" onchange="sim.layers[${i}].z=parseFloat(this.value)">
        d <input value="${L.d}" onchange="sim.layers[${i}].d=parseFloat(this.value)">
        n′ <input value="${L.n}" onchange="sim.layers[${i}].n=parseFloat(this.value)">
        n″ <input value="${L.k}" onchange="sim.layers[${i}].k=parseFloat(this.value)">
      </div>`;
    div.appendChild(d);
  });
}
function addLayer(){
  sim.layers.push({z:4,d:0.4,n:1.4,k:0});
  renderLayers();
}
function removeLayer(i){sim.layers.splice(i,1);renderLayers();}
renderLayers();

/* =====================================================
   CANVAS DRAW
   ===================================================== */
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
function resize(){
  canvas.width=canvas.clientWidth;
  canvas.height=canvas.clientHeight;
}
window.addEventListener("resize",resize); resize();

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const strips=sim.layers.length+2;
  const H=canvas.height/strips;
  const zMax=10;
  const k=2*Math.PI/sim.lambda;
  const amps=solveStack(k,sim.layers);


  function drawWaves() {
    for (let iWall = 0; iWall < walls.length - 1; iWall++) {
      const wall=walls[iWall];
      if (abs2(wall.amplitudeForwards) > 0.00000000001) {
        let start = 1;
        ctx.strokeStyle="green";
        ctx.beginPath();
        const iFrom =Math.floor(wall.position*canvas.width / zMax);
        const iTo = Math.floor(walls[iWall + 1].position * canvas.width / zMax);
        for(let i=iFrom; i < iTo; i++){
          const z = i * zMax / canvas.width;
          const E=mul(wall.amplitudeForwards, expi(k * wall.n2 *z + sim.phase));
          const x = i;
          const y=200.0 + E.re * 20.0;
          if (start) {
            ctx.moveTo(x, y);
            start = 0;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      if (abs2(wall.amplitudeBackwards) > 0.00000000001) {
        let start = 1;
        ctx.strokeStyle="red";
        ctx.beginPath();
        const iTo =Math.floor(wall.position*canvas.width / zMax);
        const iFrom = Math.floor(walls[iWall - 1].position * canvas.width / zMax);
        for(let i=iFrom; i < iTo; i++){
          const z = (iTo - i) * zMax / canvas.width;
          const E=mul(wall.amplitudeBackwards, expi(k * wall.n1 *z + sim.phase));
          const x = i;
          const y=300.0 + E.re * 20.0;
          if (start) {
            ctx.moveTo(x, y);
            start = 0;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      // combined wave
      {
        const wall1=walls[iWall];
        const wall2=walls[iWall + 1];
        let start = 1;
        ctx.strokeStyle="purple";
        ctx.beginPath();
        const iFrom =Math.floor(wall1.position*canvas.width / zMax);
        const iTo = Math.floor(wall2.position * canvas.width / zMax);
        for(let i=iFrom; i < iTo; i++){
          const z1 = i * zMax / canvas.width;
          const z2 = (iTo - i) * zMax / canvas.width;
          const E1=mul(wall1.amplitudeForwards, expi(k * wall1.n2 *z1 + sim.phase));
          const E2=mul(wall2.amplitudeBackwards, expi(k * wall2.n1 *z2 + sim.phase));
          const E=add(E1,E2);
          const x = i;
          const y=400.0 + E.re * 20.0;
          if (start) {
            ctx.moveTo(x, y);
            start = 0;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }

    }
  }
  
  function drawWave(y0){

    ctx.beginPath();
    for(let i=0;i<canvas.width;i++){
      const z=zMax*i/canvas.width;
      const E=fieldAt(z,k,amps);
      const y=y0+H/2-0.4*H*
        (E.re*Math.cos(sim.phase)-E.im*Math.sin(sim.phase));
      i?ctx.lineTo(i,y):ctx.moveTo(i,y);
    }
    ctx.stroke();
  }

  function drawArrow(ctx, x1, x2, y1) {
    const headlen = 5; 
    const angle = Math.atan2(0, x2 - x1);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y1);
    ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y1 - headlen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(x2, y1);
    ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y1 - headlen * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
  }

  function drawRays(){
    ctx.strokeStyle="orange";
    rays.forEach((ray, iRay)=>{
      const startWall=walls[ray.sWall];
      const endWall=walls[ray.sWall+ray.direction];
      const n = ray.direction===1?startWall.n2:startWall.n1;
      //const n2=ray.direction===1?endWall.n1:endWall.n2;
      const x1=(startWall.position/zMax)*canvas.width;
      const x2=(endWall.position/zMax)*canvas.width;
      const y1=50 + 12*iRay;
      const y2=y1;
      drawArrow(ctx, x1, x2, y1);
      ctx.fillStyle="black";
      ctx.fillText(`I=${ray.intensity.toFixed(4)} P=${ray.phase.toFixed(3)}`, (x1+x2)/2, y1 - 5);
    });
  }

  function drawTotalRays(){
    ctx.strokeStyle="green";
    walls.forEach((wall, iWall)=>{
      const x=wall.position/zMax*canvas.width;
      const y=500 + 12*iWall;
      const Af=wall.amplitudeForwards;
      const Ab=wall.amplitudeBackwards;
      const If=abs2(Af) * wall.n2;
      const Ib=abs2(Ab) * wall.n1;
      if (If > 0.0000000001) {
        drawArrow(ctx, x, x + 20, y);
        ctx.fillStyle="black";
        ctx.fillText(`I=${If.toFixed(3)}`, x + 25, y - 5);
      }
      if (Ib > 0.0000000001) {
        drawArrow(ctx, x, x - 20, y + 15);
        ctx.fillStyle="black";
        ctx.fillText(`I=${Ib.toFixed(3)}`, x - 25, y + 20);
      }
    });
  }

  ctx.strokeStyle="#000"; //drawWave(0);

  sim.layers.forEach((L,i)=>{
    ctx.fillStyle="rgba(180,180,180,0.3)";
    ctx.fillRect(canvas.width*L.z/zMax,10,
                 canvas.width*L.d/zMax,H);
    // ctx.strokeStyle="#2563eb";
    // drawWave((i+1)*H);
  });

  // ctx.strokeStyle="#16a34a"; drawWave((strips-1)*H);

  // /* ENERGY FLUX ARROWS */
  // ctx.strokeStyle="red";
  // for(let i=0;i<canvas.width;i+=40){
  //   const z=zMax*i/canvas.width;
  //   const f=fluxAt(z,k,amps);
  //   const len=Math.min(20,10*f);
  //   ctx.beginPath();
  //   ctx.moveTo(i,canvas.height-10);
  //   ctx.lineTo(i+len,canvas.height-10);
  //   ctx.lineTo(i+len,canvas.height-20);
  //   ctx.stroke();
  // }

  drawRays();
  drawTotalRays();
  drawWaves();
}

/* =====================================================
   LOOP & EVENTS
   ===================================================== */
function loop(){
  if(sim.running){
    sim.phase-=0.05;
    draw();
  }
  requestAnimationFrame(loop);
}
loop();

runBtn.onclick=()=>{
  sim.running=!sim.running;
  runBtn.textContent=sim.running?"Pause":"Run";
  if (sim.running) {
    buildWalls();
    buildRays();
    buildTotalRays();
    console.log("Walls:", walls);
    console.log("Rays:", rays);

  }
};
lambdaInput.onchange=e=>sim.lambda=parseFloat(e.target.value);
helpBtn.onclick=()=>helpOverlay.style.display="block";
</script>

</body>
</html>
