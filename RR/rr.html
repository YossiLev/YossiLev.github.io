<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Thin Layer Optics – Transfer Matrix</title>

<style>
:root{
  --bg:#f2f4f8; --panel:#fff; --border:#d0d5dd;
  --accent:#3b82f6; --text:#1f2937;
}
body{
  margin:0; font-family:system-ui,sans-serif;
  background:var(--bg); color:var(--text);
}
#topbar{
  display:flex; gap:12px; padding:10px;
  background:#111827; color:white; align-items:center;
}
#topbar input,#topbar select,#topbar button{
  padding:6px 10px; border-radius:6px; border:none;
}
#topbar button{background:var(--accent); color:white; cursor:pointer;}
#container{display:flex; height:calc(100vh - 52px);}
#controls{
  min-width:180px; width:180px; background:var(--panel);
  border-right:1px solid var(--border);
  padding:12px; overflow:auto;
}
.layer{
  border:1px solid var(--border);
  border-radius:10px; padding:10px; margin-bottom:10px;
  background:#fafafa;
}
.layerHeader{display:flex; justify-content:space-between; font-weight:600;}
.layerGrid{
  display:grid; grid-template-columns:1fr 1fr; gap:6px; font-size:13px; padding:10px;
}
.layerGrid input{width:100%; padding:4px;}
canvas{flex:1; background:white;}

#helpOverlay{
  position:fixed; inset:0; background:rgba(0,0,0,0.4);
  display:none; z-index:10;
}
.helpFrame{
  position:absolute; background:white; padding:14px;
  border-radius:10px; width:260px;
}

/* Group of switches laid out horizontally */
.switch-group {
  display: flex;
  align-items: center;
  gap: 18px;
  flex-wrap: wrap;          /* wraps on small screens */
}

/* Each switch+label unit */
.switch-row {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

/* Switch body */
.switch {
  position: relative;
  width: 42px;
  height: 22px;
}

/* Hide native checkbox */
.switch input {
  position: absolute;
  opacity: 0;
  pointer-events: none;
}

/* Track */
.slider {
  position: absolute;
  inset: 0;
  background: #cfd7df;
  border-radius: 999px;
  transition: background 0.25s ease;
  cursor: pointer;
}

/* Knob */
.slider::before {
  content: "";
  position: absolute;
  width: 18px;
  height: 18px;
  left: 2px;
  top: 2px;
  background: white;
  border-radius: 50%;
  box-shadow: 0 1px 3px rgba(0,0,0,0.35);
  transition: transform 0.25s ease;
}

/* Checked */
.switch input:checked + .slider {
  background: #0969da;
}

.switch input:checked + .slider::before {
  transform: translateX(20px);
}

/* Keyboard focus */
.switch input:focus-visible + .slider {
  outline: 2px solid #0969da;
  outline-offset: 2px;
}

/* Label text */
.switch-text {
  font-size: 13px;
  color: #f4f6f8;
  user-select: none;
}

</style>
</head>

<body>

<div id="topbar">
  λ₀:
  <input type="number" id="lambdaInput" value="1" step="0.1">
  Preset:
  <select id="presetSelect"></select>
  <button id="runBtn">Run</button>
  <button id="resetBtn">Reset</button>
  <button id="helpBtn">Help</button>
</div>

<div id="container">
  <div id="controls">
    <h3>Layers</h3>
    <div id="layers"></div>
    <button onclick="addLayer(0)">Add layer</button>
    <button onclick="addLayer(1)">Repeat</button>
    <button onclick="addLayer(2)">R2</button>
  </div>
  <canvas id="canvas"></canvas>
</div>

<div id="helpOverlay" onclick="this.style.display='none'">
  <div class="helpFrame" style="top:100px; left:10%; color: green;">Forward waves</div>
  <div class="helpFrame" style="top:200px; left:10%; color: red;">Backward waves</div>
  <div class="helpFrame" style="top:300px; left:10%; color: purple">Combined forward and backward waves</div>
</div>

<script>
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

/* =====================================================
   COMPLEX ARITHMETIC
   ===================================================== */
function c(re,im=0){return{re,im};}
function cop(a) {return c(a.re, a.im);}
function add(a,b){return c(a.re+b.re,a.im+b.im);}
function sub(a,b){return c(a.re-b.re,a.im-b.im);}
function mul(a,b){return c(a.re*b.re-a.im*b.im,a.re*b.im+a.im*b.re);}
function div(a,b){const d=b.re*b.re+b.im*b.im;return c((a.re*b.re+a.im*b.im)/d,(a.im*b.re-a.re*b.im)/d);}
function expi(x){return c(Math.cos(x),Math.sin(x));}
function expc(z){const e=Math.exp(z.re);return c(e*Math.cos(z.im),e*Math.sin(z.im));}
function abs2(z){return z.re*z.re+z.im*z.im;}
function abs(z){return Math.sqrt(abs2(z));}
function phase(z){return Math.atan2(z.im,z.re);}
const unitCmat = () => [[c(1.0), c(0.0)], [c(0.0), c(1.0)]];
const printCMat = (m, name="") => {
  if (name.length > 0) {
    console.log(`------ ${name}`);
  }
  console.log(`[${m[0][0].re.toFixed(6)}+${m[0][0].im.toFixed(6)}i , ${m[0][1].re.toFixed(6)}+${m[0][1].im.toFixed(6)}i]`);
  console.log(`[${m[1][0].re.toFixed(6)}+${m[1][0].im.toFixed(6)}i , ${m[1][1].re.toFixed(6)}+${m[1][1].im.toFixed(6)}i]`);
}
const multCmat = (m1, m2) => [
  [add(mul(m1[0][0], m2[0][0]), mul(m1[0][1], m2[1][0])), add(mul(m1[0][0], m2[0][1]), mul(m1[0][1], m2[1][1]))],
  [add(mul(m1[1][0], m2[0][0]), mul(m1[1][1], m2[1][0])), add(mul(m1[1][0], m2[0][1]), mul(m1[1][1], m2[1][1]))]];
const multCmatVec = (m, v) => [add(mul(m[0][0], v[0]), mul(m[0][1], v[1])), add(mul(m[1][0], v[0]), mul(m[1][1], v[1]))];
const swapCmat = (m) => [[cop(m[1][0]), cop(m[1][1])], [cop(m[0][0]), cop(m[0][1])]];
const shCmat = (m) => [
  [sub(c(0.0), div(m[0][0], m[0][1])), div(c(1.0), m[0][1])],
  [sub(m[1][0], div(mul(m[1][1], m[0][0]), m[0][1])), div(m[1][1], m[0][1])]];
const shakeCmat = (m) => swapCmat(shCmat(m));
const unshakeCmat = (m) => shCmat(swapCmat(m));
const rCoeff = (n1, n2) => div(sub(n1, n2), add(n2, n1));
const tCoeff = (n1, n2) => div(mul(c(2), n1), add(n2, n1));
const wallMat = (n1, n2) => [[rCoeff(n1, n2), tCoeff(n2, n1)], [tCoeff(n1, n2), rCoeff(n2, n1)]];
const progMat = (n, L) => [[expc(mul(n, c(0.0, L))), c(0.0)], [c(0.0), expc(mul(n, c(0.0, -L)))]];

/* =====================================================
   SIM STATE + PRESETS
   ===================================================== */
const sim={ lambda:1, phase:0, running:false, layers:[]/* layer = {z, d, n, k} */ }; 
const startWall = {type: "start", position: 0.0, n1: c(- 1), n2: c(1)};
const walls=[]; /* wall = {type, position, n1, n2} */
//const startRay = {sWall: 0, direction: 1, amplitude: c(1.0), intensity: 1.0, sTime: 0};
//const rays=[]; /* ray = {sWall, direction (1 left to right, -1 right to left), amplitude, intensity, sTime} */
let totalSystemMat = unitCmat();
let totalSolutionMat = unitCmat();

const presets={
  "Free space":()=>[],
  "Partial reflection":()=>[{type: "slab", z: 3, d: 0.5, n: 1.5, k: 0}],
  "Fabry–Pérot":()=>[{type: "slab", z: 3, d: 0.25, n: 3, k: 0}, {type: "slab", z: 4.25, d: 0.25, n: 3, k: 0}],
  "Anti-reflection λ/4":()=>[{type: "slab", z: 3, d: 0.25, n: Math.sqrt(1.5), k: 0}],
  "Anti-reflection coating":()=>[{type: "slab", z: 2, d: 0.14434180138, n: 1.732, k: 0},{type: "slab", z: -1, d: 0.4, n: 3, k: 0},{type: "slab", z: -1, d: 0.14434180138, n: 1.732, k: 0}],
  "Absorbing layer":()=>[{type: "slab", z: 3, d: 0.8, n: 1.5, k: 0.4}]
};

/* =====================================================
   build walls and rays
   ===================================================== */
function buildWalls() {
  walls.length=0;
  walls.push(startWall);
  let nPrev=c(1);
  sim.layers.forEach(L=>{
    if (L.z > 0.0) {
        walls.push({position: L.z, n1: nPrev, n2: c(L.n, L.k)});
        walls.push({position: L.z+L.d, n1: c(L.n, L.k), n2: c(1)});

    } else {
        walls[walls.length - 1].n2 = c(L.n, L.k);
        walls.push({position: walls[walls.length - 1].position+L.d, n1: c(L.n, L.k), n2: c(1)});

    }
    nPrev=c(1);
  });
  walls.push({position: 10.0, n1: c(1), n2: c(1)});

  // calculate transfer mat of the whole sysytem
  const k=2*Math.PI/sim.lambda;

  walls.forEach((w, i, a) => {
    if (i == 0) {
      totalSystemMat = unitCmat();
      // printCMat(totalSystemMat, "Unit mat");
    } else if (i < a.length - 1) {
      const stageMat = multCmat(shakeCmat(wallMat(w.n1, w.n2)), progMat(w.n1, (w.position - walls[i - 1].position) * k));
      totalSystemMat = multCmat(stageMat, totalSystemMat);
      // printCMat(progMat(w.n1, (w.position - walls[i - 1].position) * k), `progMat ${i}`);
      // printCMat(shakeCmat(wallMat(w.n1, w.n2)), `shake wall ${i}`);
      // printCMat(stageMat, `stageMat ${i}`);
      // printCMat(totalSystemMat, `totalSystemMat ${i}`);
    }
  });
  // solution is held in solMat[0][0] the returning ray at z=0, 
  // and -solMat[1][0] the anvancin ray at the exit of the last real wall
  totalSolutionMat = unshakeCmat(totalSystemMat);
  
  // printCMat(totalSystemMat, "total System Mat");
  // printCMat(totalSolutionMat, "unshake System Mat");

  let amp = [c(1.0), cop(totalSolutionMat[0][0])];
  walls[0].af = c(1.0);
  walls[0].ab = c(0.0);
  walls.filter((w, i) => i > 0).forEach((w, iz, a) => {
    let i = iz + 1;
    amp = multCmatVec(progMat(w.n1, (w.position - walls[i - 1].position) * k), amp);
    w.ab = amp[1];
    amp = multCmatVec(shakeCmat(wallMat(w.n1, w.n2)), amp);
    w.af = amp[0];
  });
}

// function buildRays() {
//   let accuracy = document.getElementById("bgHighAccuracy").checked ? 1e-12 : 1e-6;
//   const k=2*Math.PI/sim.lambda;

//   rays.length=0;
//   rays.push(startRay);
//   let nextRayIndex = 0;
//   while (nextRayIndex < rays.length && rays.length < 1000000) {
//     const ray = rays[nextRayIndex];
//     const nextWallIndex = ray.sWall + ray.direction;
//     const lastN = ray.direction === 1 ? walls[ray.sWall].n2 : walls[ray.sWall].n1;
//     if (nextWallIndex < 1 || nextWallIndex >= walls.length - 1) {
//       nextRayIndex++;
//       continue;
//     }
//     const wall = walls[nextWallIndex];
//     const n1 = ray.direction === 1 ? wall.n1 : wall.n2;
//     const n2 = ray.direction === 1 ? wall.n2 : wall.n1;
//     const r = rCoeff(n1, n2);
//     const t = tCoeff(n1, n2);
//     const z = Math.abs(wall.position - walls[ray.sWall].position);
//     const endAmplitude = mul(ray.amplitude, expc(c(-z * k * lastN.im, z * k * lastN.re)));
//     const reflectedAmplitude = mul(endAmplitude, r);
//     const reflectedIntensity = abs2(reflectedAmplitude) * n1.re;
//     const transmittedAmplitude = mul(endAmplitude, t);
//     const transmittedIntensity = abs2(transmittedAmplitude) * n2.re;
//     const stime = ray.sTime + Math.abs(wall.position - walls[ray.sWall].position);
//     if (reflectedIntensity > accuracy) {
//       rays.push({
//         sWall: nextWallIndex,
//         direction: -ray.direction,
//         amplitude: reflectedAmplitude,
//         intensity: reflectedIntensity,
//         sTime: ray.sTime
//       });
//     }
//     if (transmittedIntensity > accuracy) {
//       rays.push({
//         sWall: nextWallIndex,
//         direction: ray.direction,
//         amplitude: transmittedAmplitude,
//         intensity: transmittedIntensity,
//         sTime: ray.sTime
//       });
//     }
//     nextRayIndex++;
//   }
// }

// function buildTotalRays() {
//   for (const wall of walls) {
//     wall.amplitudeForwards = c(0, 0);
//     wall.amplitudeBackwards = c(0, 0);
//   }
//   for (let ray of rays) {
//     const wall = walls[ray.sWall];
//     if (ray.direction === 1) {
//       wall.amplitudeForwards = add(wall.amplitudeForwards, ray.amplitude)
//     } else {
//       wall.amplitudeBackwards = add(wall.amplitudeBackwards, ray.amplitude);
//     }
//   }
// }

const presetSelect=document.getElementById("presetSelect");
Object.keys(presets).forEach(p=>{
  const o=document.createElement("option"); o.textContent=p;
  presetSelect.appendChild(o);
});
presetSelect.onchange=()=>{
  sim.layers=presets[presetSelect.value]();
  renderLayers();
  buildAll();
  draw();
};
presetSelect.value="Partial reflection";
presetSelect.onchange();

/* =====================================================
   UI
   ===================================================== */
function renderLayerInput(i, prop, label){
  const L=sim.layers[i];
  return `${label} <input value="${L[prop]}" onchange="sim.layers[${i}].${prop}=parseFloat(this.value)" onkeydown="digitSpinner(event)">`;
}
function renderLayers(){
  const div=document.getElementById("layers");
  div.innerHTML="";
  sim.layers.forEach((L,i)=>{
    const d=document.createElement("div");
    d.className="layer";
    d.innerHTML=`
      <div class="layerHeader">${L.type} ${i+1}
        <button onclick="removeLayer(${i})">✕</button>
      </div>
      <div class="layerGrid">
        ${renderLayerInput(i, "z", "z")}
        ${renderLayerInput(i, "d", "d")}
        ${renderLayerInput(i, "n", "n′")}
        ${renderLayerInput(i, "k", "n″")}
      </div>`;
    div.appendChild(d);
  });
}
function addLayer(repeat){
  if (repeat > 0 && sim.layers.length >= repeat) {
    for (let ir = 0; ir < repeat; ir++) {
      const lr = sim.layers[sim.layers.length - (repeat - 1) - 1];
      const ls = sim.layers[sim.layers.length - 1];
      sim.layers.push({type: "slab", z: ls.z + 2.0 * lr.d, d: lr.d, n: lr.n, k: lr.k});
    }
  } else {
    sim.layers.push({type: "slab", z: 4, d: 0.4, n: 1.4, k: 0});
  }
  renderLayers();
  buildAll();
  draw();
}
function removeLayer(i){
  sim.layers.splice(i,1);
  renderLayers();
  buildAll();
  draw();
}
renderLayers();
buildAll();
draw();

/* =====================================================
   CANVAS DRAW
   ===================================================== */
function resize(){
  canvas.width=canvas.clientWidth;
  canvas.height=canvas.clientHeight;
}
window.addEventListener("resize",resize); resize();

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const strips=sim.layers.length+2;
  const H=canvas.height/strips;
  const zMax=10;
  const k=2*Math.PI/sim.lambda;

  function drawWaves() {
    ctx.lineWidth=3;

    for (let iWall = 0; iWall < walls.length - 1; iWall++) {
      const wall=walls[iWall];
      if (abs2(wall.af) > 0.00000000001) {
        const Ev = [];
        const iFrom =Math.floor(wall.position*canvas.width / zMax);
        const iTo = Math.floor(walls[iWall + 1].position * canvas.width / zMax);
        for(let i=iFrom; i < iTo; i++){
          const z = (i - iFrom) * zMax / canvas.width;
          const E=mul(wall.af, expc(c(-wall.n2.im * z, k * wall.n2.re *z + sim.phase)));
          Ev.push(E);
        }
        ctx.strokeStyle="green";
        let start = 1;
        ctx.beginPath();
        for(let i=iFrom; i < iTo; i++){
          const x = i;
          const y=100.0 - Ev[i-iFrom].re * 20.0;
          if (start) {
            ctx.moveTo(x, y);
            start = 0;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      if (abs2(wall.ab) > 0.00000000001) {
        let start = 1;
        ctx.strokeStyle="red";
        ctx.beginPath();
        const iTo =Math.floor(wall.position*canvas.width / zMax);
        const iFrom = Math.floor(walls[iWall - 1].position * canvas.width / zMax);
        for(let i=iFrom; i < iTo; i++){
          const z = (iTo - i) * zMax / canvas.width;
          const E=mul(wall.ab, expc(c(-wall.n1.im * z, k * wall.n1.re *z + sim.phase)));
          const x = i;
          const y=200.0 - E.re * 20.0;
          if (start) {
            ctx.moveTo(x, y);
            start = 0;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      // combined wave
      {
        const wall1=walls[iWall];
        const wall2=walls[iWall + 1];
        let start = 1;
        ctx.strokeStyle="purple";
        ctx.beginPath();
        const iFrom =Math.floor(wall1.position*canvas.width / zMax);
        const iTo = Math.floor(wall2.position * canvas.width / zMax);
        for(let i=iFrom; i < iTo; i++){
          const z1 = (i - iFrom) * zMax / canvas.width;
          const z2 = (iTo - i) * zMax / canvas.width;
          const E1=mul(wall1.af, expc(c(-wall1.n2.im * z1, k * wall1.n2.re *z1 + sim.phase)));
          const E2=mul(wall2.ab, expc(c(-wall2.n1.im * z2, k * wall2.n1.re *z2 + sim.phase)));
          const E=add(E1,E2);
          const x = i;
          const y=300.0 - E.re * 20.0;
          if (start) {
            ctx.moveTo(x, y);
            start = 0;
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }

    }
    ctx.lineWidth=1;

  }
  
  function drawArrow(ctx, x1, x2, y1) {
    const headlen = 5; 
    const angle = Math.atan2(0, x2 - x1);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y1);
    ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y1 - headlen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(x2, y1);
    ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y1 - headlen * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
  }

  function drawAmplitudeAccumulation(ctx, amplitudes, location) {
    let amp = c(0.0);
    const x0 = 600; y0 = -200 + location * 400;
    ctx.fillStyle = "#c5c8ce42";
    ctx.fillRect(x0 - 100, y0 - 100, 200, 200);
    oldStyle = ctx.strokeStyle;
    ctx.strokeStyle = "#444444";
    ctx.beginPath(); ctx.moveTo(x0 + 50, y0); ctx.lineTo(x0 - 50, y0); ctx.moveTo(x0, y0 + 50); ctx.lineTo(x0, y0 - 50); ctx.stroke();
    ctx.strokeStyle = oldStyle;
    
    ctx.beginPath();
    ctx.moveTo(x0 + amp.re, y0 + amp.im);
    for (let i = 0; i < Math.min(500, amplitudes.length); i++) {
      amp = add(amp, amplitudes[i]);
      ctx.lineTo(x0 + amp.re * 100.0, y0 + amp.im * 100.0);
    }
    ctx.stroke();
  }
  // function drawRays(){
  //   if (!document.getElementById("bgShowRays").checked) return;
  //   ctx.font="10px sans-serif";
  //   rays.filter((ray, iRay)=>iRay < 300).forEach((ray, iRay)=>{
  //     const startWall=walls[ray.sWall];
  //     const endWall=walls[ray.sWall+ray.direction];
  //     const n = ray.direction===1?startWall.n2:startWall.n1;
  //     //const n2=ray.direction===1?endWall.n1:endWall.n2;
  //     const x1=(startWall.position/zMax)*canvas.width;
  //     const x2=(endWall.position/zMax)*canvas.width;
  //     const y1=50 + 12*iRay;
  //     const y2=y1;
  //     ctx.strokeStyle=ray.direction === 1 ? "green" : "red";
  //     drawArrow(ctx, x1, x2, y1);
  //     ctx.fillStyle="black";
  //     ctx.fillText(`I=${ray.intensity.toFixed(4)} A=${abs(ray.amplitude).toFixed(4)} P=${(phase(ray.amplitude).toFixed(4)/ (2 * Math.PI)).toFixed(3)}`, (x1+x2)/2, y1 - 1);
  //   });
  //   if (!document.getElementById("bgShowRayAccum").checked) return;
  //   const spaceIndex = parseInt(document.getElementById("spaceIndexInput").value);
  //   if (spaceIndex < 1 || spaceIndex > walls.length) return;

  //   ctx.strokeStyle="green";
  //   drawAmplitudeAccumulation(ctx, rays.filter(r => r.sWall == spaceIndex - 1 && r.direction == 1).map(r => r. amplitude), 1);
  //   ctx.strokeStyle="red";
  //   drawAmplitudeAccumulation(ctx, rays.filter(r => r.sWall == spaceIndex && r.direction == - 1).map(r => r. amplitude), 2);
  // }

  function drawTotalRays(mode){
    walls.forEach((wall, iWall)=>{
      const x =wall.position/zMax*canvas.width;
      const y = (mode == 1 ? 700 : 400) + 30 * iWall;
      const Af = mode == 1 ? wall.amplitudeForwards : wall.af;
      const Ab = mode == 1 ? wall.amplitudeBackwards : wall.ab;
      const If =abs2(Af) * wall.n2.re;
      const Ib =abs2(Ab) * wall.n1.re;
      if (If > 0.0000000001) {
        ctx.strokeStyle="green";
        drawArrow(ctx, x, x + 20, y + 15);
        ctx.fillStyle="black";
        ctx.fillText(`I=${If.toFixed(5)}`, x + 25, y + 15 - 3);
      }
      if (Ib > 0.0000000001) {
        ctx.strokeStyle="red";
        drawArrow(ctx, x, x - 20, y);
        ctx.fillStyle="black";
        ctx.fillText(`I=${Ib.toFixed(5)}`, x - 25, y - 3);
      }
    });
  }

  sim.layers.forEach((L,i)=>{
    const z = L.z >= 0 ? L.z : walls[i + 1].position;
    const color = i % 2 === 1 ? "rgba(180,180,180,0.3)" : "rgba(180,130,150,0.3)";
    ctx.fillStyle=color;
    ctx.fillRect(canvas.width*z/zMax,10,
                 canvas.width*L.d/zMax,800);
  });

  //drawRays();
  //drawTotalRays(1);
  drawTotalRays(2);
  drawWaves();
}

/* =====================================================
   LOOP & EVENTS
   ===================================================== */
function loop(){
  if(sim.running){
    sim.phase-=0.05;
    draw();
  }
  requestAnimationFrame(loop);
}
loop();

function buildAll() {
  buildWalls();
  console.log("Walls:", walls);
  //console.log("Rays:", rays);

}
runBtn.onclick=()=>{
  sim.running=!sim.running;
  runBtn.textContent=sim.running?"Pause":"Run";
  if (sim.running) {
    buildAll();
  }
};
resetBtn.onclick=()=>{
  sim.running=false;
  runBtn.textContent="Run";
  sim.phase = 0;
  buildAll();
  draw();
};


function digitSpinner(e) {
  if (e.key !== "ArrowUp" && e.key !== "ArrowDown") return;
  e.preventDefault();

  const input = e.target;
  const dir = (e.key === "ArrowUp") ? +1 : -1;
  const pos = input.selectionStart;
  let s = input.value;
  let dot = s.indexOf(".");

  if (pos >= s.length) {
    input.value = s + (dir > 0 ? "1" : "9");
    input.setSelectionRange(input.value.length - 1, input.value.length - 1);
    input.dispatchEvent(new Event("change", { bubbles: true }));

    buildAll();
    draw();

    return;
  }

  let i = pos;
  while (i >= 0 && !isDigit(s[i])) i--;
  if (i < 0) return;

  let power;
  if (dot === -1 || i < dot)
    power = Math.pow(10, (dot === -1 ? s.length : dot) - i - 1);
  else
    power = Math.pow(10, dot - i);

  let value = parseFloat(s);
  value += dir * power;

  const decimals = (s.split(".")[1] || "").length;
  input.value = value.toFixed(decimals);
  input.setSelectionRange(pos, pos);

  input.dispatchEvent(new Event("change", { bubbles: true }));
  buildAll();
  draw();
}

function isDigit(c) {
  return c >= "0" && c <= "9";
}

lambdaInput.onchange=e=> {
  sim.lambda=parseFloat(e.target.value);
  buildAll();
  draw();
}
helpBtn.onclick=()=>helpOverlay.style.display="block";
</script>

</body>
</html>
