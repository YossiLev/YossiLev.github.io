<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Thin Layer Optics – Transfer Matrix</title>

<style>
:root{
  --bg:#f2f4f8; --panel:#fff; --border:#d0d5dd;
  --accent:#3b82f6; --text:#1f2937;
}
body{
  margin:0; font-family:system-ui,sans-serif;
  background:var(--bg); color:var(--text);
}
#topbar{
  display:flex; gap:12px; padding:10px;
  background:#111827; color:white; align-items:center;
}
#topbar input,#topbar select,#topbar button{
  padding:6px 10px; border-radius:6px; border:none;
}
#topbar button{background:var(--accent); color:white; cursor:pointer;}
#container{display:flex; height:calc(100vh - 52px);}
#controls{
  width:330px; background:var(--panel);
  border-right:1px solid var(--border);
  padding:12px; overflow:auto;
}
.layer{
  border:1px solid var(--border);
  border-radius:10px; padding:10px; margin-bottom:10px;
  background:#fafafa;
}
.layerHeader{display:flex; justify-content:space-between; font-weight:600;}
.layerGrid{
  display:grid; grid-template-columns:1fr 1fr; gap:6px; font-size:13px;
}
.layerGrid input{width:100%; padding:4px;}
canvas{flex:1; background:white;}

#helpOverlay{
  position:fixed; inset:0; background:rgba(0,0,0,0.6);
  display:none; z-index:10;
}
.helpFrame{
  position:absolute; background:white; padding:14px;
  border-radius:10px; width:260px;
}
</style>
</head>

<body>

<div id="topbar">
  λ₀:
  <input type="number" id="lambdaInput" value="1" step="0.1">
  Preset:
  <select id="presetSelect"></select>
  <button id="runBtn">Run</button>
  <button id="helpBtn">Help</button>
</div>

<div id="container">
  <div id="controls">
    <h3>Layers</h3>
    <div id="layers"></div>
    <button onclick="addLayer()">Add layer</button>
  </div>
  <canvas id="canvas"></canvas>
</div>

<div id="helpOverlay" onclick="this.style.display='none'">
  <div class="helpFrame" style="top:20%; left:10%;">Incident / reflected wave</div>
  <div class="helpFrame" style="top:45%; left:40%;">Internal standing waves</div>
  <div class="helpFrame" style="top:70%; left:15%;">Energy flux arrows</div>
</div>

<script>
/* =====================================================
   COMPLEX ARITHMETIC
   ===================================================== */
function c(re,im=0){return{re,im};}
function add(a,b){return c(a.re+b.re,a.im+b.im);}
function sub(a,b){return c(a.re-b.re,a.im-b.im);}
function mul(a,b){
  return c(a.re*b.re-a.im*b.im,a.re*b.im+a.im*b.re);
}
function div(a,b){
  const d=b.re*b.re+b.im*b.im;
  return c((a.re*b.re+a.im*b.im)/d,(a.im*b.re-a.re*b.im)/d);
}
function expi(x){return c(Math.cos(x),Math.sin(x));}
function expc(z){
  const e=Math.exp(z.re);
  return c(e*Math.cos(z.im),e*Math.sin(z.im));
}
function abs2(z){return z.re*z.re+z.im*z.im;}

/* =====================================================
   TRANSFER MATRIX
   ===================================================== */
function interfaceM(n1,n2){
  const r = div(sub(n2,n1), add(n2,n1));
  const t = div(c(2*n1.re,2*n1.im), add(n2,n1));
  return [
    [div(c(1),t), div(r,t)],
    [div(r,t), div(c(1),t)]
  ];
}

function propagationM(k,n,d){
  const phi = mul(c(0,k*d), n); // i*k*n*d
  return [
    [expc(phi), c(0)],
    [c(0), expc(c(-phi.re,-phi.im))]
  ];
}

function matMul(A,B){
  return [
    [
      add(mul(A[0][0],B[0][0]),mul(A[0][1],B[1][0])),
      add(mul(A[0][0],B[0][1]),mul(A[0][1],B[1][1]))
    ],
    [
      add(mul(A[1][0],B[0][0]),mul(A[1][1],B[1][0])),
      add(mul(A[1][0],B[0][1]),mul(A[1][1],B[1][1]))
    ]
  ];
}

function solveStack(k,layers){
  let M=[[c(1),c(0)],[c(0),c(1)]];
  let nPrev=c(1);

  for(const L of layers){
    const n=c(L.n,L.k);
    M=matMul(interfaceM(nPrev,n),M);
    M=matMul(propagationM(k,n,L.d),M);
    nPrev=n;
  }
  M=matMul(interfaceM(nPrev,c(1)),M);

  const Aplus=c(1);
  const Aminus=div(mul(c(-1),M[1][0]),M[1][1]);
  return {Aplus,Aminus};
}

/* =====================================================
   FIELD EVALUATION
   ===================================================== */
function fieldAt(z,k,amps){
  let z0=0;
  let Ap=amps.Aplus, Am=amps.Aminus;

  for(const L of sim.layers){
    if(z<L.z){
      return add(mul(Ap,expi(k*z)),mul(Am,expi(-k*z)));
    }
    const dz=L.z-z0;
    Ap=mul(Ap,expi(k*dz));
    Am=mul(Am,expi(-k*dz));

    if(z<=L.z+L.d){
      const n=c(L.n,L.k);
      const zz=z-L.z;
      return add(
        mul(Ap,expc(mul(c(0,k*zz),n))),
        mul(Am,expc(mul(c(0,-k*zz),n)))
      );
    }
    const n=c(L.n,L.k);
    Ap=mul(Ap,expc(mul(c(0,k*L.d),n)));
    Am=mul(Am,expc(mul(c(0,-k*L.d),n)));
    z0=L.z+L.d;
  }
  return add(
    mul(Ap,expi(k*(z-z0))),
    mul(Am,expi(-k*(z-z0)))
  );
}

/* =====================================================
   ENERGY FLUX (Poynting proxy)
   ===================================================== */
function fluxAt(z,k,amps){
  const E=fieldAt(z,k,amps);
  return abs2(E);
}

/* =====================================================
   SIM STATE + PRESETS
   ===================================================== */
const sim={
  lambda:1, phase:0, running:false, layers:[]
};

const presets={
  "Free space":()=>[],
  "Partial reflection":()=>[{z:3,d:0.5,n:1.5,k:0}],
  "Fabry–Pérot":()=>[
    {z:3,d:0.2,n:2,k:0},
    {z:4,d:0.2,n:2,k:0}
  ],
  "Anti-reflection λ/4":()=>[
    {z:3,d:0.25,n:Math.sqrt(1.5),k:0}
  ],
  "Absorbing layer":()=>[
    {z:3,d:0.8,n:1.5,k:0.4}
  ]
};

const presetSelect=document.getElementById("presetSelect");
Object.keys(presets).forEach(p=>{
  const o=document.createElement("option"); o.textContent=p;
  presetSelect.appendChild(o);
});
presetSelect.onchange=()=>{
  sim.layers=presets[presetSelect.value]();
  renderLayers();
};
presetSelect.value="Partial reflection";
presetSelect.onchange();

/* =====================================================
   UI
   ===================================================== */
function renderLayers(){
  const div=document.getElementById("layers");
  div.innerHTML="";
  sim.layers.forEach((L,i)=>{
    const d=document.createElement("div");
    d.className="layer";
    d.innerHTML=`
      <div class="layerHeader">Layer ${i+1}
        <button onclick="removeLayer(${i})">✕</button>
      </div>
      <div class="layerGrid">
        z <input value="${L.z}" onchange="sim.layers[${i}].z=parseFloat(this.value)">
        d <input value="${L.d}" onchange="sim.layers[${i}].d=parseFloat(this.value)">
        n′ <input value="${L.n}" onchange="sim.layers[${i}].n=parseFloat(this.value)">
        n″ <input value="${L.k}" onchange="sim.layers[${i}].k=parseFloat(this.value)">
      </div>`;
    div.appendChild(d);
  });
}
function addLayer(){
  sim.layers.push({z:4,d:0.4,n:1.4,k:0});
  renderLayers();
}
function removeLayer(i){sim.layers.splice(i,1);renderLayers();}
renderLayers();

/* =====================================================
   CANVAS DRAW
   ===================================================== */
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
function resize(){
  canvas.width=canvas.clientWidth;
  canvas.height=canvas.clientHeight;
}
window.addEventListener("resize",resize); resize();

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const strips=sim.layers.length+2;
  const H=canvas.height/strips;
  const zMax=10;
  const k=2*Math.PI/sim.lambda;
  const amps=solveStack(k,sim.layers);

  function drawWave(y0){
    ctx.beginPath();
    for(let i=0;i<canvas.width;i++){
      const z=zMax*i/canvas.width;
      const E=fieldAt(z,k,amps);
      const y=y0+H/2-0.4*H*
        (E.re*Math.cos(sim.phase)-E.im*Math.sin(sim.phase));
      i?ctx.lineTo(i,y):ctx.moveTo(i,y);
    }
    ctx.stroke();
  }

  ctx.strokeStyle="#000"; drawWave(0);

  sim.layers.forEach((L,i)=>{
    ctx.fillStyle="rgba(180,180,180,0.3)";
    ctx.fillRect(canvas.width*L.z/zMax,(i+1)*H,
                 canvas.width*L.d/zMax,H);
    ctx.strokeStyle="#2563eb";
    drawWave((i+1)*H);
  });

  ctx.strokeStyle="#16a34a"; drawWave((strips-1)*H);

  /* ENERGY FLUX ARROWS */
  ctx.strokeStyle="red";
  for(let i=0;i<canvas.width;i+=40){
    const z=zMax*i/canvas.width;
    const f=fluxAt(z,k,amps);
    const len=Math.min(20,10*f);
    ctx.beginPath();
    ctx.moveTo(i,canvas.height-10);
    ctx.lineTo(i+len,canvas.height-10);
    ctx.lineTo(i+len,canvas.height-20);
    ctx.stroke();
  }
}

/* =====================================================
   LOOP & EVENTS
   ===================================================== */
function loop(){
  if(sim.running){
    sim.phase-=0.05;
    draw();
  }
  requestAnimationFrame(loop);
}
loop();

runBtn.onclick=()=>{
  sim.running=!sim.running;
  runBtn.textContent=sim.running?"Pause":"Run";
};
lambdaInput.onchange=e=>sim.lambda=parseFloat(e.target.value);
helpBtn.onclick=()=>helpOverlay.style.display="block";
</script>

</body>
</html>
