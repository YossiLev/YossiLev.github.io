<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Curvature of Gravitation</title>
    <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../css/menus.css">
    <script src="../js/main.js"></script>
    <script src="../js/tts.js"></script>
    <script type="text/javascript" src="../js/linesGeo.js"></script>
    <script type="text/javascript" src="../js/glWorld.js"></script>
    <script type="text/javascript" src="../js/glObj.js"></script>
    <script type="text/javascript" src="../js/glMat.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body style="max-width:1000px">
<div class="headLine">
    The Curvature of Gravitation
</div>
<div class="headLine2">
    Motivation
</div>
<div class="normal">
    The current theory of gravity tells a story about objects that curve (or bend or distort) space-time.
    When no other forces exist, objects will move in straight paths at a constant speed.
    However, on a curved space-time, these straight paths behave differently than what our intuition tells us.
    And then, what we see in nature are planets orbiting the sun, and apples accelerating towards the ground.
</div>
<div class="normal">
    The aim of this presentation is to give an intuitive view of what is this <b>curved space-time</b>.
</div>
<div class="normal">
    We will explain
    <div class="list">
        <div class="listItem">
            What is a straight line on a curved space, and how looking at straight lines can expose the curvature of the space.
        </div>
        <div class="listItem">
            How can we unite space and time into a single geometrical entity called <b>a four-dimensional space-time</b>
        </div>
        <div class="listItem">
            How gravity bends that space-time, and how straight lines look on it
        </div>
    </div>
</div>
<div class="normal">
    The visualization of gravity curving space should not have been difficult.
    Unfortunately, if you Google the term "curved space time" and go to the "Images" tab,
    you will be staring at various beautiful pictures with one common problem -
    they do not correctly describe the true nature of the curvature of gravity.
</div>
<div class="headLine2">
    Quick History - Gravitation 1.0; Gravitation 2.0
</div>
<div class="normal" id="apples">
    Apples fall to the ground, and planets orbit around the sun. Isaac Newton connected both findings, explaining that
    bodies with mass attract other bodies, causing them change their motion.
    The calculation of the attraction force between mass 1 and mass 2 is given by the formula
    <span style="visibility: hidden;">. F , equals G Mass 1 times Mass 2, divided by square of the distance between the masses</span>
</div>
<div class="normal">
    \[F=\frac{GM_1M_2}{R^2}\]
</div>
<div class="normal" id="newTheory">
    In 1905, Albert Einstein introduced the theory of relativity. He then tried to generalize the theory to include
    accelerated motion. The result (in 1915) was a more general theory, to be later known as "General Relativity". The theory gave
    a new explanation to both acceleration and also the attractive forces of gravity. So it became a new theory for gravity.
    The idea was that masses distort the "fabric of space-time". In this space-time,
    the motion of all the stuff (massive objects but also light!) is distorted as well,
    so they follow curved paths in the curved space-time. A new formula gives the
    connection between "Energy-Momentum T", which is roughly the new name for Mass, and the geometric distortion of space-time,
    now called "Einstein Curvature G". Both G and T are evaluated at each point of space, and at each moment of time.
    The formula looks simple, but this is misleading. \[G=T\]
    In reality, the equation is so complicated, that in most cases, we can't solve it (except for some super simple situations).
</div>
<div class="normal">
    Let's forget about equations for a moment, and take a good look at what Einstein was suggesting.
    <div class="list">
        <div class="listItem">
            Gravitation is NOT a force! Masses to not attract each other.
        </div>
        <div class="listItem">
            Gravitation is all about reshaping the geometry of the world, changing distances between points,
            and making new roads for other masses to travel on.
        </div>
        <div class="listItem">
            Then masses follow these new roads as their default path, without and sense of being forced to do so.
            The natural free motion is along the curved paths made by gravity.
        </div>
    </div>
    These statements are a bit difficult to understand. To make it worse, Einstein did not suggest changing the
    geometry of our three-dimensional space. We first need to include a new fourth dimension of time, then treat
    all that as a unified four-dimensional object called Space-Time. Only then can we start messing with its geometry.
</div>
<div class="normal">
    What is this curved space-time that makes gravity? How can we visualize it? This is the goal of our presentation.
    So let's talk about curved spaces.
</div>
<div class="headLine2">
    Straight Lines on Curved Spaces
</div>

<div class="normal">
    Let's compare a curved surface to a non-curved (or flat) one. We can tell the difference by just
    looking at them. It is less obvious from a "top view", so press "side view" for a better look.
    You can also use the mouse to change the view as you wish
    (<span class="link" onclick="webGlPresentGuide(event, 'surface_Canvas');">Guide here</span>).
    Can you see the curvature?
</div>
<div class="normal">
    We can imagine drawing a straight line on a flat surface, but could there be a straight line on a curved surface?
    While there is an exact mathematical equation for a straight line on a curved space, we want to suggest a more
    intuitive way to look at it. Think about our surface as the field of a golf course, with all its hills and valleys.
    Then try to drive a golf cart on that field. Hold firmly to the steering wheel pointed at the forward position, and don't let
    it change. If you were driving on a flat field, your path would be straight. However, driving through hills and
    valleys will cause your cart to change direction. Even though your path is the straightest path possible.
</div>
<div class="container">
    <span class="animButton" onclick="worldSurf.activateView('side')">Side View </span>
    <span class="animButton" onclick="worldSurf.resetView()">Top View </span>
    <div>
        <canvas width="1000" height="500" id="surface_Canvas" class="canvasWebGl webGlGuide" tabindex="0"></canvas>
    </div>
   <!-- <canvas width="1000" height="600" id="surface_Canvas_Text" class="textCanvas"></canvas> -->
</div>

<div class="normal">
    Let's look at examples of such paths. Press the following buttons to put some lines on both surfaces.
    Lines start at the same point on each surface, and also with same initial direction, but the lines continue differently
    as they cling to the surface.
</div>
<div class="normal">
    <span class="animButton" onclick="worldSurf.animate('show', null, 'sGL, fGL', 3)">Two lines</span>
    <span class="animButton" onclick="worldSurf.animate('show', null, 'sGA, fGA', 3)">Parallels</span>
    <span class="animButton" onclick="worldSurf.animate('show', null, 'sGB, fGB', 3)">Spreading</span>
    <span class="animButton" onclick="worldSurf.animate('show', null, 'sGC, fGC', 3)">More Spreading</span>
    <span class="animButton" onclick="worldSurf.hideObjects('sGL, fGL, sGA, fGA, sGB, fGB, sGC, fGC')">Clear Lines</span>
</div>
<div class="normal">
    Some things that are special to straight lines on curved surfaces, like there could be more than
    a single straight line between the same two points, and parallel lines may meet. Such things do not depend on
    the view point, so they still exist even if we are viewing the surface from the top. From this view point
    the curvature is a bit obscured, but the straight lines continue to tell the tail of a curved surface.
</div>
<div class="normal">
    This is important, because when we start talking about a curved three-dimensional space, we do not have the
    option to step out and directly look the curvature from a higher dimensional point. So tracking
    the paths of the straight lines becomes a valuable option.
</div>
<div class="normal">
    While we live in a three-dimensional world, understanding curvature on three-dimensional spaces is not enough.
    The curved object, that drives gravity, has four dimensions. The three dimensions of space and another single
    dimension of time. Every "point" in that space is made out of 4 numbers (coordinates). Three numbers describe
    the location of the "point", while an additional number marks the time. The "point" is no longer a position,
    but rather an "event".
</div>
<div class="headLine2">
    The Geometry of Space-time
</div>
<div class="normal">
    <div class="insertImage">
        <img class="normalImage normalImageLarge" src="../images/spaceTime.png" alt="Space Time"/>
        <div class="imageLabel">Fig #st1# - Space Time</div>
    </div>
    We want to describe space-time as a geometry. What could be the picture to draw? It should display all the
    events that happen, and for each event show the location and also the time. The picture should include all
    the events of some story.
</div>
<div class="normal">
    For example, let's examine a race between a rabbit and a turtle.
    Both start at point A racing towards point B. The rabbit is faster, but once it got to the mid-point of the race,
    it fell asleep for some time, while the turtle continued past the rabbit. Later, the rabbit
    woke up and continued to run, but it was too late.
</div>
<div class="normal">
    The whole story is shown in the following picture. The rabbit's path is in red, and turtle gets the blue path.
    Every point on this picture represents an event, that is something that happened at a certain exact location and at
    a certain exact time.
    The horizontal coordinate of an event holds the position, that is "Where", while the vertical holds the time, the "When".
    If you see that some participant in the scenario, has a vertical line, this means that while time is passing,
    position is not changing. This matches a participant staying put for some period of time, so no motion.
    On the other hand, we never see a horizontal line, as this would have meant a participant being at
    more than one position at the same time, which is not possible.
</div>
<div class="normal">
    Such a map has two dimensions, one of space and one of time, jointly called Space-Time. We see all the points on
    it (the events) and can draw lines between them. So we can treat them as if they belong to a geometry,
    using geometrical terms, like length, slope, etc. While it is two-dimensional, the usual way is to say that it
    has 1&nbsp;+&nbsp;1 (one plus one) dimensions. So we emphasize that there is one position dimension and one time dimension.
</div>
<div class="normal">
    The physical space we live in is described using three coordinates to mark the position of a certain object.
    If we want to talk of our space-time, it should have 3&nbsp;+&nbsp;1 (three plus one) dimensions. All together four dimensions.
</div>
<div class="normal">
    Let's make a smaller step and talk about 2&nbsp;+&nbsp;1 dimensions. By that we mean, two dimensions of space with one dimension
    of time. Again, we meet our rabbit and turtle, but now they are free to move on a two-dimensional plain.
    So they race again, but not from point A to point B, but rather on a circular track. The full space-time will be, of course,
    a three-dimensional thing (see below). The checkered floor marks the two coordinates of space, while the green
    arrow is the time coordinate, the "When".
    <div class="containerLeft">
        <div>
            <span class="animButton" onclick="world2dPlus1.resetView()">Top view</span>
            <span class="animButton" onclick="world2dPlus1.activateView('side')">Side view</span>
            <span class="animButton" onclick="world2dPlus1.activateView('side2')">Side 2</span>
            <span class="animButton" onclick="world2dPlus1.animate('moveTo', [0, 0, 0.5, 0, 0, 0], 'floor', 8)">Run Time</span>
            <span class="animButton" onclick="world2dPlus1.animate('moveTo', [0, 0, 0, 0, 0, 0], 'floor', 0.1)">Reset Time</span>
        </div>
        <canvas width="600" height="600" id="2dp1_Canvas" class="canvasWebGl webGlGuide" tabindex="0"></canvas>
    </div>
</div>
<div class="normal">
    Do try playing around with the view of this 2&nbsp;+&nbsp;1 world. One interesting point of view is the "Top View".
    It shows all the places where the two buddies were passing through. And that is the circle or the racetrack. On the other hand,
    the "Side View" show the events including how time was playing into matter. So we can see each participant speed
    (this is the slope of the line, the more fast you are the less steep is your line). Convince yourself that you
    understand that the rabbit (red path) is generally faster than the turtle (blue path). See the vertical red
    line that represents staying in place.
</div>
<div class="normal">
    While each point of view teaches us some part of the full story, so we need to always change our point of view to get the
    whole story and feel comfortable with what each part represents.
</div>
<div class="normal">
    Another thing to look at is a single slice of time. Look at the current state of the floor.
    It represents the state of the world at a certain moment, the time of the start of the race.
    So we see the red and blue paths hit that floor plain, at a certain location.
    This is the starting point of the race.
    If we place the floor at a higher point, it would mean a later time into the race.
    If we continuously move the floor upwards, we would advance in time and could track both paths through the entire race.
    Press the "run time" button to let time pass and track the points where the paths hit the floor.
</div>

<div class="headLine2">
    The Curved Space-time of Gravitation
</div>
<div class="normal">
    So now we have some understanding about the thing we call space-time.
    We have seen it from all angles, we understand the meaning of paths along space-time. What is still missing is how gravity
    curve this space-time.
</div>
<div class="normal">
    One thing we can do, is to list the straight paths created by gravity. For this, we will use
    our knowledge about motions that gravity inspires. Yes, we are eventually back to "falling apples and orbiting planets".
</div>
<div class="normal">
    So we will talk about the interaction between two bodies, one big against one small. Like the Earth against an apple,
    or the Sun against the Earth. In both cases, the motion of the big object will feel little effect, so it would be
    practically not moving (great! this is a simple vertical line in space-time, standing still!). That big
    object will be the most significant contributor to the effect on space-time curvature. So the smaller object will
    travel along a straight path in the unchanging curved space-time.
</div>
<div class="normal">
    We will examine these paths below, where on the right there will be an animation of the motion like it look in our
    three-dimensional world, while the left is the space-time view of a 2&nbsp;+&nbsp;1 dimensions.
</div>
<div>
    <div class="structNavBlock">
        <div id="segmentApples" class="structNav" onclick="onNavigateSegment(event)">Falling Apples</div>
        <div id="segmentPlanets" class="structNav" onclick="onNavigateSegment(event)">Orbiting Planets</div>
        <div id="segmentOthers" class="structNav" onclick="onNavigateSegment(event)">Other Motions</div>
        <div id="segmentOptions"></div>
        <div id="mainFall" class="mainPart segmentApples">
            <span class="mainHeader">Apples in free fall</span>
            We know what happens to an apple when we hold and apple on our hand and let go.
            It moves straight down towards the earth in a growing speed.
            Click <span class="animButton" onclick="animFall();">Fall</span> to see the simulation of the motion on
            the right simulation window then look at the path in the space-time on the left side.
            Did you notice that the initial direction of the apple in the space-time view is vertical.
            This is because the apple was at rest at the beginning.
        </div>
        <div id="mainThrow" class="mainPart segmentApples">
            <span class="mainHeader">Throw the apple up in the air</span>
            Another well know path of our apple is to throw it up un the air. We know what's going to happen. The apple
            will climb while loosing speed. Then from the top of the path, it will continue to accelerate down just as before.
            Click <span class="animButton" onclick="animThrow();">Throw</span> to see that simulation and see how this new
            path differs from the previous one, of just dropping the apple.
        </div>
        <div id="mainThrowDown" class="mainPart segmentApples">
            <span class="mainHeader">Throw the apple down to the ground</span>
            In a similar manner we can also ask what happens if we throw the apple down.
            <span class="animButton" onclick="animThrowDown();">Throw Down</span>
        </div>
        <div id="mainThrowLater" class="mainPart segmentApples">
            <span class="mainHeader">Drop the apple, but at a later time</span>
            Remember that we are looking for straight lines in space-time experiencing gravitation. In that sense, the paths
            of an apple that is being dropped now is different from the path of making the drop a bit later or a bit earlier
            from now.
            <span class="animButton" onclick="animFallLater();">Drop Later/Earlier</span>
        </div>
        <div id="mainCircular" class="mainPart segmentPlanets">
            <span class="animButton" onclick="worldSolar.animatePath(glBuild.getEllipseFunction(0.2, 0.2), 'earth1', 5);">Circular Orbit</span>
        </div>
        <div id="mainElliptic" class="mainPart segmentPlanets">
            <span class="animButton" onclick="worldSolar.animatePath(glBuild.getEllipseFunction(0.4, 0.346), 'earth1', 5);">Elliptic</span>
        </div>
    </div>
</div>
<div class="containerFlex">
    <div>
        <canvas width="500" height="400" id="solar_Canvas2D" class="canvasWebGl" tabindex="0"></canvas>
        <span class="animButton" onclick="worldSolar2D.activateView('side')">Side view</span>
        <span class="animButton" onclick="worldSolar2D.activateView('top')">Top view</span>
    </div>
    <canvas width="480" height="400" id="solar_Canvas" class="canvasWebGl " tabindex="0"></canvas>
</div>
<div>
</div>
<div class="normal">
    So we had concerns about understanding curvature in three dimensions, but the real target is to get to four.
    Are we lost? Not really, because gravitation effects are really intuitive and easy to grasp.
    All we need to do is to take what we know about how gravitation affects objects and translate it into geometry.
</div>
<div class="container">
    <div>
        <span class="animButton" onclick="world.activateView('side')">Side View</span>
        <span class="animButton" onclick="world.activateView('normal')">Normal View</span>
        <span class="animButton" onclick="world.resetView()">Top View </span>
    </div>
    <canvas width="1000" height="500" id="my_Canvas" class="canvasWebGl" tabindex="0"></canvas>
</div>
<div id="objBut"></div>

<script>
    let worldSurf = new glWorld();
    worldSurf.addToRoot('sineS', glBuild.sineSurface(0.25, 0.09, [-0.2, 0, 0, 0, 0, 0], [1, 0.6, 0.6]));
    worldSurf.addToRoot('flatS', glBuild.flatSurface(0.25, [0.2, 0, 0, 0, 0, 0], [0.6, 0.6, 1]));

    let hideOptions = { show: false };
    worldSurf.addToRoot('sGL', glBuild.geodesicOnSurface(worldSurf.getObjectByName('sineS'), 0.2, 0.1, 0.000, 0.02, 100, [0.8, 1, 0], 0.001), hideOptions);
    worldSurf.addToRoot('fGL', glBuild.geodesicOnSurface(worldSurf.getObjectByName('flatS'), 0.2, 0.1, 0.000, 0.02, 100, [0.8, 1, 0], 0.001), hideOptions);
    worldSurf.addToRoot('sGL', glBuild.geodesicOnSurface(worldSurf.getObjectByName('sineS'), 0.8, 0.4, -0.03, 0.02, 100, [0.8, 1, 0], 0.001), hideOptions);
    worldSurf.addToRoot('fGL', glBuild.geodesicOnSurface(worldSurf.getObjectByName('flatS'), 0.8, 0.4, -0.03, 0.02, 100, [0.8, 1, 0], 0.001), hideOptions);

    for (let x = 0.1; x < 1.0; x += 0.05) {
        worldSurf.addToRoot('sGA', glBuild.geodesicOnSurface(worldSurf.getObjectByName('sineS'), x, 0.05, 0.0, 0.01, 100, [1, 1, 1], 0.001), hideOptions);
        worldSurf.addToRoot('fGA', glBuild.geodesicOnSurface(worldSurf.getObjectByName('flatS'), x, 0.05, 0.0, 0.01, 100, [1, 1, 1], 0.001), hideOptions);
    }
    for (let a = 0.0; a < Math.PI / 2; a += 0.1) {
        worldSurf.addToRoot('sGB', glBuild.geodesicOnSurface(worldSurf.getObjectByName('sineS'), 0.1, 0.1, 0.0001 * Math.sin(a), 0.0001 * Math.cos(a), 100, [1, 1, 0.4], 0.001), hideOptions);
        worldSurf.addToRoot('fGB', glBuild.geodesicOnSurface(worldSurf.getObjectByName('flatS'), 0.1, 0.1, 0.0001 * Math.sin(a), 0.0001 * Math.cos(a), 100, [1, 1, 0.4], 0.001), hideOptions);
    }
    for (let a = Math.PI / 4; a < 3 * Math.PI / 4; a += 0.1) {
        worldSurf.addToRoot('sGC', glBuild.geodesicOnSurface(worldSurf.getObjectByName('sineS'), 0.1, 0.5, 0.0001 * Math.sin(a), 0.0001 * Math.cos(a), 100, [0.7, 1, 1], 0.001), hideOptions);
        worldSurf.addToRoot('fGC', glBuild.geodesicOnSurface(worldSurf.getObjectByName('flatS'), 0.1, 0.5, 0.0001 * Math.sin(a), 0.0001 * Math.cos(a), 100, [0.7, 1, 1], 0.001), hideOptions);
    }

    worldSurf.addToRoot('lineList', glBuild.listOfLine([-0.2, 0, 0, 0, 0, 0], [1, 0, 0]));
    worldSurf.addLabelView('side', [1.3737387097273113, 0, 0, 0, 0, 2.2895645162121854, 0, 0, 0, 0, -0.10512820512820514, -0.1, 0, 0, -0.20512820512820512, 0, 0.9998266232097757, 0.006730336679404935, -0.017361626914537763, 0, -0.016057591928409165, 0.7837095817816787, -0.6209198379541808, 0, 0.009427473807888864, 0.6210909707858957, 0.7836817777298599, 0, 0, 0, 0, 1]);

    worldSurf.prepare(document.getElementById('surface_Canvas'));
    worldSurf.startAnimation();

    let world2dPlus1 = new glWorld();
    world2dPlus1.addToRoot('floor', glBuild.floor(3, 0.1));
    world2dPlus1.addToRoot('helixTurtle', glBuild.helixCurve(0.4, 0.2, 1, 0.003, [0.0, 0, 0, 0, 0, 0], [0, 0.5, 1]));
    world2dPlus1.addToRoot('helixRabbit1', glBuild.helixCurve(0.2, 0.2, 0.5, 0.003, [0.0, 0, 0, 0, 0, 0], [1, 0, 0]));
    world2dPlus1.addToRoot('helixRabbit2', glBuild.helixCurve(0.2, 0.2, 0.5, 0.003, [0.0, 0, 0.35, 0, 0, 180], [1, 0, 0]));
    world2dPlus1.addToRoot('lineRabbit', glBuild.segmentCurve([- 0.2, 0, 0.1], [- 0.2, 0, 0.35], 0.003, [0.0, 0, 0, 0, 0, 0], [1, 0, 0]));
    world2dPlus1.addToRoot('arrow', glBuild.arrow(0.5, 0.05, 0.005, 0.02, [- 0.25, 0.25, 0, 0, 0, 0], [0, 1, 0]));
    world2dPlus1.addLabelView('side', [0, -0.23, -0.1, -80, 0, 0]);
    world2dPlus1.addLabelView('side2', [ 1.3737387097273113, 0, 0, 0, 0, 1.8316516129697482, 0, 0, 0.017, -0.0026, -0.10512820512820514, -0.1, 0, 0, -0.20512820512820512, 0,
        -0.02510639970324361, 0.035361579898365365, 0.9990591711010072, 0, 0.9996096857158929, -0.011361541273127367, 0.025522374553865218, 0, 0.012253363493742966, 0.9993099989727874, -0.03506253037217399, 0, 0.055530609659277703, -0.2443674538718856, 0.010044843405483055, 1]);
    world2dPlus1.prepare(document.getElementById('2dp1_Canvas'));
    world2dPlus1.startAnimation();


    let worldSolar = new glWorld();
    worldSolar.addToRoot('sun', glBuild.sphere(0.035, 20, [0.0, 0, 0.0, 0, 0, 0], [0.9, 0.9, 0.0]));
    worldSolar.addToRoot('earth1', glBuild.sphere(0.005, 20, [0.2, 0, 0.0, 0, 0, 0], [0.34, 0.72, 0.89]));
    //worldSolar.addToRoot('earth2', glBuild.sphere(0.6, 150, [-0.6, 0.0, 0.0, 0, 0, 0], [0.34, 0.72, 0.89]));
    //worldSolar.addToRoot('apple', glBuild.sphere(0.005, 20, [0.2, 0.0, 0.0, 0, 0, 0], [1, 0.3, 0.1]));
    //worldSolar.addToRoot('orbit', glBuild.ellipse(0.4, 0.346, 0.001, [0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0]));
    //    worldSolar.addToRoot('orbit', glBuild.ellipse(0.24, 0.16, 0.001, [0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1]));
    //    worldSolar.addToRoot('orbit', glBuild.ellipse(0.3, 0.16, 0.001, [0, 0, 0, 0, 0, 90], [0, 1, 1]));
    //    worldSolar.addToRoot('orbit', glBuild.ellipse(0.4, 0.16, 0.001, [0, 0, 0, 0, 0, 160], [1, 1, 0, 1, 0, 0]));
    worldSolar.prepare(document.getElementById('solar_Canvas'))
    worldSolar.startAnimation();

    hideOptions = { show: true };
    let worldSolar2D = new glWorld();
    worldSolar2D.addToRoot('fl', glBuild.segmentCurve([- 0.4, 0, 0], [0.4, 0, 0], 0.0005, [0, 0, 0, 0, 0, 0], [0.2, 0.2, 0.2]));
    worldSolar2D.addToRoot(`@flx`, glBuild.makeClone([0, 0, 0, 0, 0, 90], worldSolar2D.getObjectByName(`fl`)));
    for (let i = 1; i <= 4; i++) {
        worldSolar2D.addToRoot(`@fl${i}p`, glBuild.makeClone([0, i * 0.1, 0, 0, 0, 0], worldSolar2D.getObjectByName(`fl`)));
        worldSolar2D.addToRoot(`@fl${i}n`, glBuild.makeClone([0, - i * 0.1, 0, 0, 0, 0], worldSolar2D.getObjectByName(`fl`)));
        worldSolar2D.addToRoot(`@flx${i}p`, glBuild.makeClone([i * 0.1, 0, 0, 0, 0, 90], worldSolar2D.getObjectByName(`fl`)));
        worldSolar2D.addToRoot(`@flx${i}n`, glBuild.makeClone([-i * 0.1, 0, 0, 0, 0, 90], worldSolar2D.getObjectByName(`fl`)));
    }
    worldSolar2D.addToRoot('arrow', glBuild.arrow(0.5, 0.05, 0.005, 0.02, [- 0.25, 0.25, 0, 0, 0, 0], [0, 1, 0]));

    worldSolar2D.addToRoot('sun', glBuild.sphere(0.035, 20, [0.0, 0, 0.0, 0, 0, 0], [0.9, 0.9, 0.0]));
    worldSolar2D.addToRoot('earth1', glBuild.sphere(0.005, 20, [0.2, 0, 0.0, 0, 0, 0], [0.34, 0.72, 0.89]));
    //worldSolar2D.addToRoot('earth2', glBuild.sphere(0.03, 20, [0, 0.0, 0.0, 0, 0, 0], [0.34, 0.72, 0.89]));
    //worldSolar2D.addToRoot('apple', glBuild.sphere(0.005, 20, [0.2, 0.0, 0.0, 0, 0, 0], [1, 0.3, 0.1]));

    hideOptions = { show: false };

    worldSolar2D.addToRoot('fall', glBuild.freeFallSpaceTimeCurve(0.2, 0, - 0.05, 3, 0.001, [0.0, 0, 0.0, 0, 0, 0], [0.9, 0.9, 0.9]), hideOptions);
    worldSolar2D.addToRoot('throw', glBuild.freeFallSpaceTimeCurve(0.2, 0.1, - 0.05, 6, 0.001, [0.0, 0, 0.0, 0, 0, 0], [0.9, 0.9, 0.9]), hideOptions);
    worldSolar2D.addToRoot('throwDown', glBuild.freeFallSpaceTimeCurve(0.2, -0.1, - 0.05, 1.6, 0.001, [0.0, 0, 0.0, 0, 0, 0], [0.9, 0.9, 0.9]), hideOptions);
    worldSolar2D.addLabelView('side', [0, -0.3, 0, -90, 0, 0], true);
    worldSolar2D.addLabelView('top', [0, 0, 0, 0, 0, 0], true);

    const animFall = () => {
        worldSolar.animatePath(glBuild.getFreeFallFunction(0.2, 0, - 0.05, 3), 'earth1', 3).then((r) => {
            worldSolar2D.showObjects('fall');
        });
    }
    const animThrow = () => {
        worldSolar.animatePath(glBuild.getFreeFallFunction(0.2, 0.1, - 0.05, 6), 'earth1', 3).then((r) => {
            worldSolar2D.showObjects('throw');
        });
    }
    const animThrowDown = () => {
        worldSolar.animatePath(glBuild.getFreeFallFunction(0.2, - 0.1, - 0.05, 2), 'earth1', 3).then((r) => {
            worldSolar2D.showObjects('throwDown');
        });
    }
    const animFallLater = () => {
        worldSolar2D.showObjects('@fallClonesTime');
    }
    worldSolar2D.addToRoot('orbitEllipse', glBuild.ellipseSpaceTimeCurve(0.24, 0.16, 6, 0.005, [0.0, 0, 0.0, 0, 0, 0], [0.1, 0.1, 0.1, 0.4, 0.4, 1]), hideOptions);
    worldSolar2D.addToRoot('orbitCircle', glBuild.ellipseSpaceTimeCurve(0.2, 0.2, 6, 0.003, [0, 0, 0.0, 0, 0, 0], [1.0, 0.3, 0.3, 0.6, 0.1, 0.1]), hideOptions);
    worldSolar2D.addToRoot('orbitCircleRev', glBuild.ellipseSpaceTimeCurve(- 0.2, 0.2, 6, 0.003, [0.0, 0, 0.0, 0, 0, 0], [0.3, 1., 0.3, 0.1, 0.6, 0.1]), hideOptions);
    for (let i = 30; i < 360; i += 30) {
        worldSolar2D.addToRoot(`@orbitCircleClonesRotate`, glBuild.makeClone([0, 0, 0, 0, 0, i], worldSolar2D.getObjectByName(`orbitCircle`)), hideOptions);
        worldSolar2D.addToRoot(`@orbitCircleRevClonesRotate`, glBuild.makeClone([0, 0, 0, 0, 0, i], worldSolar2D.getObjectByName(`orbitCircleRev`)), hideOptions);
        worldSolar2D.addToRoot(`@orbitEllipseClonesRotate`, glBuild.makeClone([0, 0, 0, 0, 0, i], worldSolar2D.getObjectByName(`orbitEllipse`)), hideOptions);
    }
    for (let i = 0; i < 5; i++) {
        worldSolar2D.addToRoot(`@fallClonesTime`, glBuild.makeClone([0, 0, 0.1 * i, 0, 0, 0], worldSolar2D.getObjectByName(`fall`)), hideOptions);
        worldSolar2D.addToRoot(`@fallClonesTime`, glBuild.makeClone([0, 0, -0.1 * i, 0, 0, 0], worldSolar2D.getObjectByName(`fall`)), hideOptions);
        worldSolar2D.addToRoot(`@throwClonesTime`, glBuild.makeClone([0, 0, 0.1 * i, 0, 0, 0], worldSolar2D.getObjectByName(`throw`)), hideOptions);
        worldSolar2D.addToRoot(`@throwClonesTime`, glBuild.makeClone([0, 0, -0.1 * i, 0, 0, 0], worldSolar2D.getObjectByName(`throw`)), hideOptions);
    }

  //      worldSolar2D.addToRoot('orbit', glBuild.ellipse(0.2, 0.2, 0.001, [0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0]));
  //      worldSolar2D.addToRoot('orbit', glBuild.ellipse(0.24, 0.16, 0.001, [0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1]));
  //      worldSolar2D.addToRoot('orbit', glBuild.ellipse(0.3, 0.16, 0.001, [0, 0, 0, 0, 0, 90], [0, 1, 1]));
  //      worldSolar2D.addToRoot('orbit', glBuild.ellipse(0.4, 0.16, 0.001, [0, 0, 0, 0, 0, 160], [1, 1, 0, 1, 0, 0]));

    worldSolar2D.prepare(document.getElementById('solar_Canvas2D'))
    worldSolar2D.startAnimation();

    let world = new glWorld();
    world.addToRoot('floor', glBuild.floor(4, 0.1));
    //world.addToRoot('helix', glBuild.helixCurve(0.2, 0.1, 6, 0.001, [0, 0, 0, 0, 45, 0], [0, 1, 0]));
    world.addToRoot('helix1', glBuild.helixCurve(0.05, 0.1, 12, 0.001, [0.0, 0, 0, 0, 0, 0], [1, 0, 0]));
    world.addToRoot('helix2', glBuild.helixCurve(0.1, 0.1 * 1.58740, 6, 0.001, [0.0, 0, 0, 0, 0, 0], [1, 1, 0]));
    world.addToRoot('helix3', glBuild.helixCurve(0.15, 0.1 * 2.08008, 4, 0.001, [0.0, 0, 0, 0, 0, 0], [1, 0, 1]));
    //world.addToRoot('tr', glBuild.trefoilKnotCurve(0.003, [0, 0, 0.1, 0, 0, 0], [1, 0, 0.5]));
    //world.addToRoot('sine', glBuild.sineCurve(0.001, [0, 0, 0, 0, 0, 0], [1, 0.7, 0]));

    //for (let i = 0; i <= 20; i++) {
    //    world.addToRoot(`@sf${i}`, glBuild.arc3dCurve(0.8, (i - 10) * 0.1, -1, 1, 0.005, [0, 0, 0, 0, 0, 0], [1, 1, 0]));
    //    world.addToRoot(`@sfc${i}`, glBuild.makeClone([0, 0, 0, 0, 90, 0], world.getObjectByName(`@sf${i}`)));
    //}
    world.addLabelView('side', [
        1.3737387097273113, 0, 0, 0,
        0, 2.976433871075841, 0, 0,
        0.0026000000000000003,  0.07640000000000018, -0.10512820512820514, -0.1,
        0, 0, -0.20512820512820512, 0,
        0.5259727162298479, -0.0011621583573477596, 0.0018774619800226494, 0,
        0.0018868109693413453, 0.004257001136427263, -0.5259567392660992, 0,
        0.001146917564586616, 0.525958839666198, 0.004261132575165785, 0, 0, 0, 0, 1]);
    world.addLabelView('normal', [1.3737387097273113, 0, 0, 0,
        0, 2.976433871075841, 0, 0,
        0.013400000000000009, 0.058000000000000086, -0.10512820512820514, -0.1,
        0, 0, -0.20512820512820512, 0,
        0.5036140512935409, 0.00783505663485207, -0.060910189895720196, 0,
        -0.06018285871009997, 0.1631393614451248, -0.4766152790990378, 0,
        0.01222550052489335, 0.48033604137176883, 0.16286920059394344, 0, 0, 0, 0, 1]);

    world.prepare(document.getElementById('my_Canvas'))
    world.startAnimation();

    const showMainPart = (e, id) => {
        getArrayByClass("structNavSub").forEach(el => {
            el.classList.remove('structNavSubOn');
        });
        e.target.classList.add('structNavSubOn')
        getArrayByClass("mainPart").forEach(el => {
            el.style.display = 'none';
        });
        document.getElementById(id).style.display = 'block';
    }
    const onNavigateSegment = (e) => {
        getArrayByClass("structNav").forEach(el => {
            el.classList.remove('structNavOn');
        });
        getArrayByClass("mainPart").forEach(el => {
            el.style.display = 'none';
        });
        e.target.classList.add('structNavOn')
        const options = [];
        getArrayByClass(e.target.id).forEach(el => {
            options.push({id: el.id, label: el.id.slice(4)});
        });
        document.getElementById("segmentOptions").innerHTML =
            options.map(o => `<span class="structNavSub" onclick="showMainPart(event, '${o.id}')">${o.label}</span>`).join(' ');
    }
</script>

</body>
</html>
